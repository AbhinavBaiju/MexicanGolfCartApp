{
  "version": 3,
  "sources": ["../bundle-C8yPJI/checked-fetch.js", "../../../src/security.ts", "../../../src/auth.ts", "../../../src/date.ts", "../../../src/config.ts", "../../../src/bookingService.ts", "../../../src/webhooks.ts", "../../../src/rateLimit.ts", "../../../src/proxy.ts", "../../../src/admin.ts", "../../../src/scheduled.ts", "../../../src/index.ts", "../../../../../../.nvm/versions/node/v24.11.1/lib/node_modules/wrangler/templates/middleware/middleware-ensure-req-body-drained.ts", "../../../../../../.nvm/versions/node/v24.11.1/lib/node_modules/wrangler/templates/middleware/middleware-miniflare3-json-error.ts", "../bundle-C8yPJI/middleware-insertion-facade.js", "../../../../../../.nvm/versions/node/v24.11.1/lib/node_modules/wrangler/templates/middleware/common.ts", "../bundle-C8yPJI/middleware-loader.entry.ts"],
  "sourceRoot": "/Users/abhinav/Documents/MexicanGolfCartApp/worker/.wrangler/tmp/dev-sMKKv7",
  "sourcesContent": ["const urls = new Set();\n\nfunction checkURL(request, init) {\n\tconst url =\n\t\trequest instanceof URL\n\t\t\t? request\n\t\t\t: new URL(\n\t\t\t\t\t(typeof request === \"string\"\n\t\t\t\t\t\t? new Request(request, init)\n\t\t\t\t\t\t: request\n\t\t\t\t\t).url\n\t\t\t\t);\n\tif (url.port && url.port !== \"443\" && url.protocol === \"https:\") {\n\t\tif (!urls.has(url.toString())) {\n\t\t\turls.add(url.toString());\n\t\t\tconsole.warn(\n\t\t\t\t`WARNING: known issue with \\`fetch()\\` requests to custom HTTPS ports in published Workers:\\n` +\n\t\t\t\t\t` - ${url.toString()} - the custom port will be ignored when the Worker is published using the \\`wrangler deploy\\` command.\\n`\n\t\t\t);\n\t\t}\n\t}\n}\n\nglobalThis.fetch = new Proxy(globalThis.fetch, {\n\tapply(target, thisArg, argArray) {\n\t\tconst [request, init] = argArray;\n\t\tcheckURL(request, init);\n\t\treturn Reflect.apply(target, thisArg, argArray);\n\t},\n});\n", "import { Env } from './types';\n\n/**\n * Common HMAC verification helper\n */\nasync function verifySignature(params: URLSearchParams, secret: string, signatureKey: string): Promise<boolean> {\n    const signatureHex = params.get(signatureKey);\n    if (!signatureHex) return false;\n\n    const tempParams = new URLSearchParams(params);\n    tempParams.delete(signatureKey);\n    // Remove the other potential key to be safe, though usually only one is present\n    if (signatureKey === 'hmac') tempParams.delete('signature');\n    if (signatureKey === 'signature') tempParams.delete('hmac');\n\n    // Sort parameters\n    const entries = Array.from(tempParams.entries()).sort((a, b) => a[0].localeCompare(b[0]));\n    const message = entries.map(([k, v]) => `${k}=${v}`).join('');\n\n    const encoder = new TextEncoder();\n    const keyData = encoder.encode(secret);\n    const messageData = encoder.encode(message);\n\n    const key = await crypto.subtle.importKey(\n        'raw',\n        keyData,\n        { name: 'HMAC', hash: 'SHA-256' },\n        false,\n        ['verify']\n    );\n\n    // Convert hex signature to buffer\n    const signature = new Uint8Array(\n        signatureHex.match(/[\\da-f]{2}/gi)!.map((h) => parseInt(h, 16))\n    );\n\n    return await crypto.subtle.verify('HMAC', key, signature, messageData);\n}\n\n/**\n * Verifies the HMAC signature for Shopify Admin OAuth (uses 'hmac' param and '&' separator)\n */\nexport async function verifyHmac(params: URLSearchParams, secret: string): Promise<boolean> {\n    const hmac = params.get('hmac');\n    if (!hmac) return false;\n\n    const tempParams = new URLSearchParams(params);\n    tempParams.delete('hmac');\n    tempParams.delete('signature');\n\n    const entries = Array.from(tempParams.entries()).sort((a, b) => a[0].localeCompare(b[0]));\n    const message = entries.map(([k, v]) => `${k}=${v}`).join('&');\n\n    const encoder = new TextEncoder();\n    const keyData = encoder.encode(secret);\n    const messageData = encoder.encode(message);\n\n    const key = await crypto.subtle.importKey(\n        'raw',\n        keyData,\n        { name: 'HMAC', hash: 'SHA-256' },\n        false,\n        ['verify']\n    );\n\n    const signature = new Uint8Array(\n        hmac.match(/[\\da-f]{2}/gi)!.map((h) => parseInt(h, 16))\n    );\n\n    return await crypto.subtle.verify('HMAC', key, signature, messageData);\n}\n\n/**\n * Verifies the signature for Shopify App Proxy requests (uses 'signature' param)\n * Note: App Proxy signature verification often differs slightly in separator usage compared to OAuth.\n * Documentation suggests using the sorted query string (implies '&').\n */\nexport async function verifyProxySignature(request: Request, secret: string): Promise<boolean> {\n    const url = new URL(request.url);\n    const params = url.searchParams;\n    const signatureHex = params.get('signature');\n\n    if (!signatureHex) return false;\n\n    const tempParams = new URLSearchParams(params);\n    tempParams.delete('signature');\n\n    // Sort parameters\n    const entries = Array.from(tempParams.entries()).sort((a, b) => a[0].localeCompare(b[0]));\n\n    // Use '&' as strict separator for Proxy as well, as it is a \"sorted query string\"\n    const message = entries.map(([k, v]) => `${k}=${v}`).join('');\n\n    const encoder = new TextEncoder();\n    const keyData = encoder.encode(secret);\n    const messageData = encoder.encode(message);\n\n    const key = await crypto.subtle.importKey(\n        'raw',\n        keyData,\n        { name: 'HMAC', hash: 'SHA-256' },\n        false,\n        ['verify']\n    );\n\n    const signature = new Uint8Array(\n        signatureHex.match(/[\\da-f]{2}/gi)!.map((h) => parseInt(h, 16))\n    );\n\n    return await crypto.subtle.verify('HMAC', key, signature, messageData);\n}\n", "import { Env } from './types';\nimport { verifyHmac } from './security';\n\ninterface JwtHeader {\n    alg: string;\n    kid?: string;\n    typ?: string;\n}\n\nexport interface SessionTokenPayload {\n    iss: string;\n    dest: string;\n    aud: string | string[];\n    exp: number;\n    nbf?: number;\n    iat?: number;\n    sub?: string;\n    sid?: string;\n}\n\ninterface JsonWebKeyWithKid extends JsonWebKey {\n    kid?: string;\n}\n\ninterface JwksResponse {\n    keys: JsonWebKeyWithKid[];\n}\n\nconst jwksCache: { keys: Map<string, JsonWebKey>; fetchedAt: number } = {\n    keys: new Map<string, JsonWebKey>(),\n    fetchedAt: 0,\n};\n\nconst JWKS_CACHE_TTL_MS = 60 * 60 * 1000;\nconst DEFAULT_JWKS_URL = 'https://shopify.dev/.well-known/jwks.json';\n\nexport async function handleAuth(request: Request, env: Env): Promise<Response> {\n    const url = new URL(request.url);\n    const shop = url.searchParams.get('shop');\n\n    if (!shop) {\n        return new Response('Missing shop parameter', { status: 400 });\n    }\n\n    // Generate a random nonce\n    const nonce = crypto.randomUUID();\n\n    // Scopes required\n    const scopes = 'read_products,write_products,read_orders,write_orders';\n    const redirectUri = `${env.SHOPIFY_APP_URL}/auth/callback`;\n    const accessMode = 'offline'; // We need offline token for background worker\n\n    const authUrl = `https://${shop}/admin/oauth/authorize?client_id=${env.SHOPIFY_API_KEY}&scope=${scopes}&redirect_uri=${redirectUri}&state=${nonce}&grant_options[]=${accessMode}`;\n\n    return Response.redirect(authUrl);\n}\n\nexport async function verifySessionToken(\n    token: string,\n    secret: string,\n    apiKey: string,\n    jwksUrl?: string\n): Promise<SessionTokenPayload | null> {\n    const parts = token.split('.');\n    if (parts.length !== 3) {\n        return null;\n    }\n    const [encodedHeader, encodedPayload, encodedSignature] = parts;\n    const header = decodeBase64UrlJson<JwtHeader>(encodedHeader);\n    const payload = decodeBase64UrlJson<SessionTokenPayload>(encodedPayload);\n\n    if (!header || !payload) {\n        return null;\n    }\n\n    const nowSeconds = Math.floor(Date.now() / 1000);\n    if (!Number.isFinite(payload.exp) || payload.exp <= nowSeconds) {\n        return null;\n    }\n    if (payload.nbf && payload.nbf > nowSeconds) {\n        return null;\n    }\n\n    if (!isAudienceMatch(payload.aud, apiKey)) {\n        return null;\n    }\n\n    const destHost = safeUrlHost(payload.dest);\n    const issHost = safeUrlHost(payload.iss);\n    if (!destHost || !issHost || destHost !== issHost) {\n        return null;\n    }\n\n    const signingInput = `${encodedHeader}.${encodedPayload}`;\n    const signature = base64UrlToUint8Array(encodedSignature);\n    const data = new TextEncoder().encode(signingInput);\n\n    if (header.alg === 'RS256') {\n        const jwk = await getShopifyJwk(header.kid, jwksUrl);\n        if (!jwk) {\n            return null;\n        }\n        const key = await crypto.subtle.importKey(\n            'jwk',\n            jwk,\n            { name: 'RSASSA-PKCS1-v1_5', hash: 'SHA-256' },\n            false,\n            ['verify']\n        );\n        const verified = await crypto.subtle.verify('RSASSA-PKCS1-v1_5', key, signature as BufferSource, data as BufferSource);\n        return verified ? payload : null;\n    }\n\n    if (header.alg === 'HS256') {\n        const key = await crypto.subtle.importKey(\n            'raw',\n            new TextEncoder().encode(secret),\n            { name: 'HMAC', hash: 'SHA-256' },\n            false,\n            ['verify']\n        );\n        const verified = await crypto.subtle.verify('HMAC', key, signature as BufferSource, data as BufferSource);\n        return verified ? payload : null;\n    }\n\n    return null;\n}\n\nexport async function handleAuthCallback(request: Request, env: Env): Promise<Response> {\n    const url = new URL(request.url);\n    const shop = url.searchParams.get('shop');\n    const code = url.searchParams.get('code');\n    const hmac = url.searchParams.get('hmac');\n    // const state = url.searchParams.get('state'); // In a real app, verify this matches the nonce set in cookie\n\n    if (!shop || !code || !hmac) {\n        return new Response('Missing required parameters', { status: 400 });\n    }\n\n    // 1. Verify HMAC\n    const valid = await verifyHmac(url.searchParams, env.SHOPIFY_API_SECRET);\n    if (!valid) {\n        return new Response('HMAC validation failed', { status: 400 });\n    }\n\n    // 2. Exchange access token\n    const accessToken = await exchangeAccessToken(shop, code, env);\n    if (!accessToken) {\n        return new Response('Failed to exchange access token', { status: 500 });\n    }\n\n    // 3. Store in DB\n    try {\n        await env.DB.prepare(\n            `INSERT INTO shops (shop_domain, access_token, installed_at) \n       VALUES (?, ?, datetime('now')) \n       ON CONFLICT(shop_domain) DO UPDATE SET \n       access_token = excluded.access_token, \n       uninstalled_at = NULL,\n       installed_at = datetime('now')`\n        )\n            .bind(shop, accessToken)\n            .run();\n    } catch (e) {\n        console.error('Database error:', e);\n        return new Response('Failed to store shop data', { status: 500 });\n    }\n\n    // 4. Register Webhook\n    await registerWebhook(shop, accessToken, env);\n\n    // Redirect to the embedded app UI or Shopify Admin\n    // Usually https://admin.shopify.com/store/{shop_name}/apps/{app_name}\n    // For now, simple success message or redirect to app home\n    // Using the host param if available to properly redirect inside admin\n    const host = url.searchParams.get('host');\n    if (host) {\n        // Decode host to base64 for the URL if needed, but usually it's passed through\n        // Actually, we usually redirect to the app's UI served by Shopify or our own UI\n        // If this is a pure backend app, maybe just say \"Installed!\"\n        return new Response(`App installed successfully for ${shop}! You can close this window.`);\n    }\n\n    return new Response(`App installed successfully for ${shop}!`);\n}\n\n\n\nasync function exchangeAccessToken(shop: string, code: string, env: Env): Promise<string | null> {\n    const body = {\n        client_id: env.SHOPIFY_API_KEY,\n        client_secret: env.SHOPIFY_API_SECRET,\n        code,\n    };\n\n    try {\n        const resp = await fetch(`https://${shop}/admin/oauth/access_token`, {\n            method: 'POST',\n            headers: {\n                'Content-Type': 'application/json',\n                'Accept': 'application/json'\n            },\n            body: JSON.stringify(body)\n        });\n\n        if (!resp.ok) {\n            const txt = await resp.text();\n            console.error('Token exchange failed', resp.status, txt);\n            return null;\n        }\n\n        const data = await resp.json() as { access_token: string };\n        return data.access_token;\n    } catch (e) {\n        console.error('Token exchange error', e);\n        return null;\n    }\n}\n\nasync function registerWebhook(shop: string, accessToken: string, env: Env) {\n    const webhooks = [\n        {\n            topic: 'orders/create',\n            address: `${env.SHOPIFY_APP_URL}/webhooks/orders/create`,\n            format: 'json',\n        },\n        {\n            topic: 'app/uninstalled',\n            address: `${env.SHOPIFY_APP_URL}/webhooks/app/uninstalled`,\n            format: 'json',\n        }\n    ];\n\n    const apiVersion = '2026-04';\n\n    for (const hook of webhooks) {\n        try {\n            const resp = await fetch(`https://${shop}/admin/api/${apiVersion}/webhooks.json`, {\n                method: 'POST',\n                headers: {\n                    'X-Shopify-Access-Token': accessToken,\n                    'Content-Type': 'application/json',\n                },\n                body: JSON.stringify({ webhook: hook }),\n            });\n\n            if (!resp.ok) {\n                const txt = await resp.text();\n                // 422 usually means already exists\n                console.log(`Webhook ${hook.topic} registration result:`, resp.status, txt);\n            } else {\n                console.log(`Webhook ${hook.topic} registered successfully`);\n            }\n        } catch (e) {\n            console.error(`Webhook ${hook.topic} registration failed`, e);\n        }\n    }\n}\n\nfunction decodeBase64UrlJson<T>(input: string): T | null {\n    try {\n        const json = new TextDecoder().decode(base64UrlToUint8Array(input));\n        return JSON.parse(json) as T;\n    } catch {\n        return null;\n    }\n}\n\nfunction base64UrlToUint8Array(input: string): Uint8Array {\n    const normalized = input.replace(/-/g, '+').replace(/_/g, '/');\n    const padding = normalized.length % 4 === 0 ? '' : '='.repeat(4 - (normalized.length % 4));\n    const base64 = normalized + padding;\n    const binary = atob(base64);\n    const bytes = new Uint8Array(binary.length);\n    for (let i = 0; i < binary.length; i += 1) {\n        bytes[i] = binary.charCodeAt(i);\n    }\n    return bytes;\n}\n\nfunction isAudienceMatch(aud: string | string[], apiKey: string): boolean {\n    if (typeof aud === 'string') {\n        return aud === apiKey;\n    }\n    if (Array.isArray(aud)) {\n        return aud.includes(apiKey);\n    }\n    return false;\n}\n\nfunction safeUrlHost(value: string): string | null {\n    try {\n        return new URL(value).host;\n    } catch {\n        return null;\n    }\n}\n\nasync function getShopifyJwk(kid?: string, jwksUrl?: string): Promise<JsonWebKey | null> {\n    const url = jwksUrl || DEFAULT_JWKS_URL;\n    const now = Date.now();\n    if (jwksCache.keys.size === 0 || now - jwksCache.fetchedAt > JWKS_CACHE_TTL_MS) {\n        const resp = await fetch(url);\n        if (!resp.ok) {\n            return null;\n        }\n        const data = (await resp.json()) as JwksResponse;\n        const map = new Map<string, JsonWebKey>();\n        for (const key of data.keys) {\n            if (key.kid) {\n                map.set(key.kid, key);\n            }\n        }\n        jwksCache.keys = map;\n        jwksCache.fetchedAt = now;\n    }\n\n    if (kid) {\n        return jwksCache.keys.get(kid) || null;\n    }\n\n    const first = jwksCache.keys.values().next();\n    return first.done ? null : first.value;\n}\n", "export interface DateParts {\n    year: number;\n    month: number;\n    day: number;\n}\n\nconst ISO_DATE_RE = /^\\d{4}-\\d{2}-\\d{2}$/;\n\nexport function parseDateParts(value: string): DateParts | null {\n    if (!ISO_DATE_RE.test(value)) {\n        return null;\n    }\n    const [yearStr, monthStr, dayStr] = value.split('-');\n    const year = Number(yearStr);\n    const month = Number(monthStr);\n    const day = Number(dayStr);\n    if (!Number.isInteger(year) || !Number.isInteger(month) || !Number.isInteger(day)) {\n        return null;\n    }\n    if (month < 1 || month > 12 || day < 1 || day > 31) {\n        return null;\n    }\n    const dt = new Date(Date.UTC(year, month - 1, day));\n    if (\n        dt.getUTCFullYear() !== year ||\n        dt.getUTCMonth() !== month - 1 ||\n        dt.getUTCDate() !== day\n    ) {\n        return null;\n    }\n    return { year, month, day };\n}\n\nexport function datePartsToIndex(parts: DateParts): number {\n    return Math.floor(Date.UTC(parts.year, parts.month - 1, parts.day) / 86400000);\n}\n\nexport function dateIndexToString(dayIndex: number): string {\n    return new Date(dayIndex * 86400000).toISOString().slice(0, 10);\n}\n\nexport function getTodayInTimeZone(timeZone: string, now: Date = new Date()): string {\n    const formatter = new Intl.DateTimeFormat('en-CA', {\n        timeZone,\n        year: 'numeric',\n        month: '2-digit',\n        day: '2-digit',\n    });\n    return formatter.format(now);\n}\n\nexport function compareDateStrings(a: string, b: string): number | null {\n    const partsA = parseDateParts(a);\n    const partsB = parseDateParts(b);\n    if (!partsA || !partsB) {\n        return null;\n    }\n    const idxA = datePartsToIndex(partsA);\n    const idxB = datePartsToIndex(partsB);\n    return idxA - idxB;\n}\n\nexport function listDateStrings(startDate: string, endDate: string): string[] | null {\n    const startParts = parseDateParts(startDate);\n    const endParts = parseDateParts(endDate);\n    if (!startParts || !endParts) {\n        return null;\n    }\n    const startIndex = datePartsToIndex(startParts);\n    const endIndex = datePartsToIndex(endParts);\n    if (startIndex > endIndex) {\n        return null;\n    }\n    const dates: string[] = [];\n    for (let i = startIndex; i <= endIndex; i += 1) {\n        dates.push(dateIndexToString(i));\n    }\n    return dates;\n}\n", "export const STORE_TIMEZONE = 'America/Mexico_City';\n", "import { Env } from './types';\nimport { datePartsToIndex, getTodayInTimeZone, parseDateParts } from './date';\nimport { STORE_TIMEZONE } from './config';\n\nexport type ReleaseTargetStatus = 'RELEASED' | 'EXPIRED';\n\ntype BookingStatus = 'HOLD' | 'CONFIRMED' | 'RELEASED' | 'EXPIRED' | 'INVALID' | 'CANCELLED';\n\ninterface BookingDayRow {\n    product_id: number;\n    date: string;\n    qty: number;\n}\n\ninterface BookingRow {\n    shop_id: number;\n    status: BookingStatus;\n}\n\ninterface BookingDetailRow {\n    id: string;\n    shop_id: number;\n    status: BookingStatus;\n    order_id: number | null;\n    start_date: string;\n    end_date: string;\n    location_code: string;\n}\n\ninterface BookingItemRow {\n    product_id: number;\n    variant_id: number;\n    qty: number;\n}\n\ninterface ProductDepositRow {\n    product_id: number;\n    deposit_variant_id: number | null;\n    deposit_multiplier: number | null;\n}\n\ninterface OrderLineItemProperty {\n    name: string;\n    value: string | number | null;\n}\n\ninterface OrderNoteAttribute {\n    name: string;\n    value: string | number | null;\n}\n\ninterface OrderLineItem {\n    product_id: number | null;\n    variant_id: number | null;\n    quantity: number;\n    price: string | null;\n    properties?: OrderLineItemProperty[] | Record<string, unknown> | null;\n}\n\ninterface OrderWebhookPayload {\n    id: number;\n    email: string | null;\n    customer: { first_name?: string; last_name?: string; email?: string } | null;\n    current_subtotal_price: string | null;\n    line_items: OrderLineItem[];\n    note_attributes: OrderNoteAttribute[];\n}\n\ninterface ConfirmOrderResult {\n    status: number;\n    body: string;\n}\n\ninterface ProcessTokenResult {\n    status: 'confirmed' | 'invalid';\n    reason: string;\n    bookingId: string | null;\n}\n\ninterface TokenExtractionResult {\n    tokens: string[];\n    lineItemsByToken: Map<string, OrderLineItem[]>;\n}\n\ninterface BookingLineItemMeta {\n    startDate: string | null;\n    endDate: string | null;\n    location: string | null;\n    error?: string;\n    fulfillmentType?: string | null;\n    deliveryAddress?: string | null;\n}\n\ninterface ShopAuthRow {\n    shop_domain: string;\n    access_token: string;\n}\n\ninterface OrderCancellationResult {\n    attempted: boolean;\n    succeeded: boolean;\n}\n\ninterface LocationRules {\n    leadTimeDays: number;\n    minDurationDays: number;\n}\n\nexport async function confirmBookingsFromOrder(\n    env: Env,\n    shopDomain: string,\n    eventId: string,\n    topic: string,\n    rawBody: string\n): Promise<ConfirmOrderResult> {\n    const db = env.DB;\n    let shopId: number | null = null;\n    let insertedEvent = false;\n\n    try {\n        const shopRow = await db.prepare('SELECT id FROM shops WHERE shop_domain = ?').bind(shopDomain).first();\n        const parsedShopId = isRecord(shopRow) ? toPositiveInt(shopRow.id) : null;\n        if (!parsedShopId) {\n            console.error('Shop not found for webhook', shopDomain);\n            return { status: 200, body: 'Shop not found' };\n        }\n        shopId = parsedShopId;\n\n        const existingEvent = await db\n            .prepare('SELECT event_id FROM webhook_events WHERE shop_id = ? AND event_id = ?')\n            .bind(shopId, eventId)\n            .first();\n        if (existingEvent) {\n            return { status: 200, body: 'Duplicate webhook event' };\n        }\n\n        try {\n            await db.prepare('INSERT INTO webhook_events (shop_id, event_id, topic) VALUES (?, ?, ?)')\n                .bind(shopId, eventId, topic)\n                .run();\n            insertedEvent = true;\n        } catch (e) {\n            const message = String(e);\n            if (message.includes('UNIQUE') || message.includes('constraint')) {\n                return { status: 200, body: 'Duplicate webhook event' };\n            }\n            console.error('Failed to record webhook event', e);\n            return { status: 500, body: 'Failed to record webhook event' };\n        }\n\n        const order = parseOrderPayload(rawBody);\n        if (!order) {\n            console.error('Invalid order payload');\n            return { status: 200, body: 'Invalid order payload' };\n        }\n\n        const customerName = [order.customer?.first_name, order.customer?.last_name].filter(Boolean).join(' ') || 'Guest';\n        const customerEmail = order.customer?.email || order.email || '';\n\n        await linkAgreementSignature(env.DB, shopDomain, order.id, order.note_attributes, customerEmail);\n\n        const extraction = extractBookingTokens(order.line_items);\n        if (extraction.tokens.length === 0) {\n            return { status: 200, body: 'No booking tokens found' };\n        }\n\n        let confirmedCount = 0;\n        let invalidCount = 0;\n        let cancellationTriggered = false;\n        let cancellationResult: OrderCancellationResult | null = null;\n\n        // Heuristic: distribute revenue evenly or just store 0 for now? \n        // Better: sum up the price of line items for this specific booking token.\n        // But price is in line_items[].price (which we aren't parsing yet).\n        // Let's rely on simple extraction or just a placeholder for now if parsing price is too complex without adding more fields.\n        // Wait, I should parse price.\n\n        // Actually, let's keep it simple for this step: \n        // We will pass the data to processBookingToken. \n        // We need to calculate revenue *per booking*. \n        // This requires parsing line item price.\n\n        for (const token of extraction.tokens) {\n            const lineItems = extraction.lineItemsByToken.get(token) ?? [];\n            const revenue = calculateBookingRevenue(lineItems);\n\n            const result = await processBookingToken(db, shopId, order.id, token, lineItems, customerName, customerEmail, revenue);\n            if (result.status === 'confirmed') {\n                confirmedCount += 1;\n            } else {\n                invalidCount += 1;\n                console.warn('Booking validation failed', { token, reason: result.reason });\n                if (!cancellationTriggered && shopId) {\n                    cancellationTriggered = true;\n                    cancellationResult = await cancelShopifyOrder(env, shopId, order.id, result.reason);\n                }\n                if (cancellationResult && !cancellationResult.succeeded && result.bookingId) {\n                    await markBookingManualReview(db, result.bookingId, 'Manual cancellation required');\n                }\n            }\n        }\n\n        const summary = `Processed ${extraction.tokens.length} booking token(s). Confirmed: ${confirmedCount}. Invalid: ${invalidCount}.`;\n        return { status: 200, body: summary };\n    } catch (e) {\n        console.error('Order webhook processing error', e);\n        if (insertedEvent && shopId) {\n            await deleteWebhookEvent(db, shopId, eventId);\n        }\n        return { status: 500, body: 'Internal Server Error' };\n    }\n}\n\nexport async function releaseBooking(\n    db: D1Database,\n    bookingId: string,\n    targetStatus: ReleaseTargetStatus\n): Promise<void> {\n    const booking = (await db\n        .prepare('SELECT shop_id, status FROM bookings WHERE id = ?')\n        .bind(bookingId)\n        .first()) as BookingRow | null;\n\n    if (!booking) {\n        throw new Error(`Booking not found: ${bookingId}`);\n    }\n\n    if (booking.status !== 'HOLD') {\n        return;\n    }\n\n    const bookingDays = await db\n        .prepare('SELECT product_id, date, qty FROM booking_days WHERE booking_id = ?')\n        .bind(bookingId)\n        .all();\n\n    const statements: D1PreparedStatement[] = [];\n    statements.push(\n        db.prepare(\n            `UPDATE bookings\n             SET status = ?, updated_at = datetime('now')\n             WHERE id = ? AND status = 'HOLD'`\n        ).bind(targetStatus, bookingId)\n    );\n    statements.push(db.prepare('SELECT CASE WHEN changes() = 1 THEN 1 ELSE 1/0 END;'));\n\n    for (const row of bookingDays.results ?? []) {\n        const bookingDay = row as unknown as BookingDayRow;\n        const productId = bookingDay.product_id;\n        const date = bookingDay.date;\n        const qty = bookingDay.qty;\n        statements.push(\n            db.prepare(\n                `UPDATE inventory_day\n                 SET reserved_qty = reserved_qty - ?\n                 WHERE shop_id = ? AND product_id = ? AND date = ? AND reserved_qty >= ?`\n            ).bind(qty, booking.shop_id, productId, date, qty)\n        );\n        statements.push(db.prepare('SELECT CASE WHEN changes() = 1 THEN 1 ELSE 1/0 END;'));\n    }\n\n    await db.batch(statements);\n}\n\nasync function processBookingToken(\n    db: D1Database,\n    shopId: number,\n    orderId: number,\n    bookingToken: string,\n    lineItems: OrderLineItem[],\n    customerName: string,\n    customerEmail: string,\n    revenue: number\n): Promise<ProcessTokenResult> {\n    const bookingRow = await db\n        .prepare('SELECT id, shop_id, status, order_id, start_date, end_date, location_code FROM bookings WHERE booking_token = ?')\n        .bind(bookingToken)\n        .first();\n    const booking = parseBookingDetailRow(bookingRow);\n    if (!booking) {\n        return { status: 'invalid', reason: 'Booking not found', bookingId: null };\n    }\n\n    if (booking.shop_id !== shopId) {\n        await markBookingInvalid(db, booking.id, 'Booking shop mismatch');\n        return { status: 'invalid', reason: 'Booking shop mismatch', bookingId: booking.id };\n    }\n\n    if (booking.status === 'CONFIRMED' && booking.order_id === orderId) {\n        return { status: 'confirmed', reason: 'Already confirmed', bookingId: booking.id };\n    }\n\n    if (booking.status !== 'HOLD') {\n        await markBookingInvalid(db, booking.id, `Booking status ${booking.status}`);\n        return { status: 'invalid', reason: `Booking status ${booking.status}`, bookingId: booking.id };\n    }\n\n    if (lineItems.length === 0) {\n        await markBookingInvalid(db, booking.id, 'Missing order line items for booking token');\n        return { status: 'invalid', reason: 'Missing order line items', bookingId: booking.id };\n    }\n\n    const lineItemMeta = extractBookingMetaFromLineItems(lineItems);\n    if (lineItemMeta.error) {\n        await markBookingInvalid(db, booking.id, lineItemMeta.error);\n        return { status: 'invalid', reason: lineItemMeta.error, bookingId: booking.id };\n    }\n    if (!lineItemMeta.startDate) {\n        await markBookingInvalid(db, booking.id, 'Missing booking start date');\n        return { status: 'invalid', reason: 'Missing booking start date', bookingId: booking.id };\n    }\n    if (!lineItemMeta.endDate) {\n        await markBookingInvalid(db, booking.id, 'Missing booking end date');\n        return { status: 'invalid', reason: 'Missing booking end date', bookingId: booking.id };\n    }\n    if (!lineItemMeta.location) {\n        await markBookingInvalid(db, booking.id, 'Missing booking location');\n        return { status: 'invalid', reason: 'Missing booking location', bookingId: booking.id };\n    }\n    if (lineItemMeta.startDate !== booking.start_date || lineItemMeta.endDate !== booking.end_date) {\n        await markBookingInvalid(db, booking.id, 'Date tampering detected');\n        return { status: 'invalid', reason: 'Date tampering detected', bookingId: booking.id };\n    }\n    if (lineItemMeta.location !== booking.location_code) {\n        await markBookingInvalid(db, booking.id, 'Location tampering detected');\n        return { status: 'invalid', reason: 'Location tampering detected', bookingId: booking.id };\n    }\n\n    const dateRuleError = await validateBookingDateRules(\n        db,\n        shopId,\n        booking.location_code,\n        booking.start_date,\n        booking.end_date\n    );\n    if (dateRuleError) {\n        await markBookingInvalid(db, booking.id, dateRuleError);\n        return { status: 'invalid', reason: dateRuleError, bookingId: booking.id };\n    }\n\n    const bookingItemsResult = await db\n        .prepare('SELECT product_id, variant_id, qty FROM booking_items WHERE booking_id = ?')\n        .bind(booking.id)\n        .all();\n    const bookingItems = normalizeBookingItems(bookingItemsResult.results ?? []);\n    if (bookingItems.length === 0) {\n        await markBookingInvalid(db, booking.id, 'Booking items missing');\n        return { status: 'invalid', reason: 'Booking items missing', bookingId: booking.id };\n    }\n\n    const uniqueProductIds = Array.from(new Set(bookingItems.map((item) => item.product_id)));\n    const productMap = await fetchProductDeposits(db, shopId, uniqueProductIds);\n    if (!productMap || productMap.size !== uniqueProductIds.length) {\n        await markBookingInvalid(db, booking.id, 'Product configuration missing');\n        return { status: 'invalid', reason: 'Product configuration missing', bookingId: booking.id };\n    }\n\n    const lineItemKeyQty = buildLineItemKeyMap(lineItems);\n    const lineItemVariantQty = buildLineItemVariantMap(lineItems);\n\n    const inventoryMismatch = validateBookingItemsMatch(bookingItems, lineItemKeyQty);\n    if (inventoryMismatch) {\n        await markBookingInvalid(db, booking.id, inventoryMismatch);\n        return { status: 'invalid', reason: inventoryMismatch, bookingId: booking.id };\n    }\n\n    const depositMismatch = validateDepositLineItems(bookingItems, productMap, lineItemVariantQty);\n    if (depositMismatch) {\n        await markBookingInvalid(db, booking.id, depositMismatch);\n        return { status: 'invalid', reason: depositMismatch, bookingId: booking.id };\n    }\n\n    // PRD \u00A76.4: Validate capacity again at confirmation time (booking_days must exist)\n    const bookingDaysResult = await db\n        .prepare('SELECT COUNT(*) as count FROM booking_days WHERE booking_id = ?')\n        .bind(booking.id)\n        .first();\n    const bookingDaysCount = bookingDaysResult && typeof bookingDaysResult.count === 'number' ? bookingDaysResult.count : 0;\n    if (bookingDaysCount === 0) {\n        await markBookingInvalid(db, booking.id, 'Capacity allocations missing');\n        return { status: 'invalid', reason: 'Capacity allocations missing', bookingId: booking.id };\n    }\n\n    const confirmed = await markBookingConfirmed(\n        db,\n        booking.id,\n        orderId,\n        customerName,\n        customerEmail,\n        revenue,\n        lineItemMeta.fulfillmentType || null,\n        lineItemMeta.deliveryAddress || null\n    );\n    if (!confirmed) {\n        const refreshed = await db.prepare('SELECT status, order_id FROM bookings WHERE id = ?').bind(booking.id).first();\n        const refreshedStatus = parseBookingStatusRow(refreshed);\n        if (refreshedStatus && refreshedStatus.status === 'CONFIRMED' && refreshedStatus.order_id === orderId) {\n            return { status: 'confirmed', reason: 'Already confirmed', bookingId: booking.id };\n        }\n        await markBookingInvalid(db, booking.id, 'Failed to confirm booking');\n        return { status: 'invalid', reason: 'Failed to confirm booking', bookingId: booking.id };\n    }\n\n    return { status: 'confirmed', reason: 'Confirmed', bookingId: booking.id };\n}\n\nasync function markBookingConfirmed(\n    db: D1Database,\n    bookingId: string,\n    orderId: number,\n    customerName: string,\n    customerEmail: string,\n    revenue: number,\n    fulfillmentType: string | null,\n    deliveryAddress: string | null\n): Promise<boolean> {\n    const result = await db\n        .prepare(\n            `UPDATE bookings\n             SET status = 'CONFIRMED', order_id = ?, customer_name = ?, customer_email = ?, revenue = ?, fulfillment_type = ?, delivery_address = ?, updated_at = datetime('now')\n             WHERE id = ? AND status = 'HOLD'`\n        )\n        .bind(orderId, customerName, customerEmail, revenue, fulfillmentType, deliveryAddress, bookingId)\n        .run();\n    return (result.meta?.changes ?? 0) > 0;\n}\n\nasync function markBookingInvalid(db: D1Database, bookingId: string, reason: string): Promise<void> {\n    try {\n        await db\n            .prepare(\n                `UPDATE bookings\n                 SET status = 'INVALID', invalid_reason = ?, updated_at = datetime('now')\n                 WHERE id = ?`\n            )\n            .bind(reason, bookingId)\n            .run();\n    } catch (e) {\n        const message = String(e);\n        if (message.includes('no such column: invalid_reason')) {\n            await db\n                .prepare(\n                    `UPDATE bookings\n                     SET status = 'INVALID', updated_at = datetime('now')\n                     WHERE id = ?`\n                )\n                .bind(bookingId)\n                .run();\n            return;\n        }\n        throw e;\n    }\n}\n\nasync function markBookingManualReview(db: D1Database, bookingId: string, note: string): Promise<void> {\n    try {\n        await db\n            .prepare(\n                `UPDATE bookings\n                 SET invalid_reason = CASE\n                     WHEN invalid_reason IS NULL OR invalid_reason = '' THEN ?\n                     WHEN instr(invalid_reason, ?) > 0 THEN invalid_reason\n                     ELSE invalid_reason || ' | ' || ?\n                 END,\n                 updated_at = datetime('now')\n                 WHERE id = ?`\n            )\n            .bind(note, note, note, bookingId)\n            .run();\n    } catch (e) {\n        const message = String(e);\n        if (message.includes('no such column: invalid_reason')) {\n            return;\n        }\n        throw e;\n    }\n}\n\nasync function cancelShopifyOrder(\n    env: Env,\n    shopId: number,\n    orderId: number,\n    reason: string\n): Promise<OrderCancellationResult> {\n    try {\n        const shopRow = await env.DB.prepare('SELECT shop_domain, access_token FROM shops WHERE id = ?')\n            .bind(shopId)\n            .first();\n        if (!shopRow) {\n            console.error('Shop not found for order cancellation', { shopId, orderId, reason });\n            return { attempted: false, succeeded: false };\n        }\n        const shopAuth = parseShopAuthRow(shopRow);\n        if (!shopAuth) {\n            console.error('Shop credentials missing for order cancellation', { shopId, orderId, reason });\n            return { attempted: false, succeeded: false };\n        }\n\n        const response = await fetch(\n            `https://${shopAuth.shop_domain}/admin/api/2024-04/orders/${orderId}/cancel.json`,\n            {\n                method: 'POST',\n                headers: {\n                    'Content-Type': 'application/json',\n                    'X-Shopify-Access-Token': shopAuth.access_token,\n                },\n                body: JSON.stringify({ email: true }),\n            }\n        );\n\n        if (!response.ok) {\n            const errorBody = await response.text();\n            console.error('Failed to cancel Shopify order', {\n                shopId,\n                orderId,\n                status: response.status,\n                reason,\n                errorBody,\n            });\n            return { attempted: true, succeeded: false };\n        }\n        return { attempted: true, succeeded: true };\n    } catch (e) {\n        console.error('Error cancelling Shopify order', { shopId, orderId, reason, error: e });\n        return { attempted: false, succeeded: false };\n    }\n}\n\nasync function fetchProductDeposits(\n    db: D1Database,\n    shopId: number,\n    productIds: number[]\n): Promise<Map<number, ProductDepositRow> | null> {\n    if (productIds.length === 0) {\n        return new Map();\n    }\n    const placeholders = productIds.map(() => '?').join(', ');\n    const result = await db\n        .prepare(\n            `SELECT product_id, deposit_variant_id, deposit_multiplier\n             FROM products\n             WHERE shop_id = ? AND product_id IN (${placeholders})`\n        )\n        .bind(shopId, ...productIds)\n        .all();\n    const rows = normalizeProductDeposits(result.results ?? []);\n    const map = new Map<number, ProductDepositRow>();\n    for (const row of rows) {\n        map.set(row.product_id, row);\n    }\n    return map;\n}\n\nasync function validateBookingDateRules(\n    db: D1Database,\n    shopId: number,\n    locationCode: string,\n    startDate: string,\n    endDate: string\n): Promise<string | null> {\n    const startParts = parseDateParts(startDate);\n    const endParts = parseDateParts(endDate);\n    if (!startParts || !endParts) {\n        return 'Invalid booking dates';\n    }\n\n    const startIndex = datePartsToIndex(startParts);\n    const endIndex = datePartsToIndex(endParts);\n    if (startIndex > endIndex) {\n        return 'Invalid booking date range';\n    }\n\n    const rules = await fetchLocationRules(db, shopId, locationCode);\n    if (!rules) {\n        return 'Location rules missing';\n    }\n\n    const todayStr = getTodayInTimeZone(STORE_TIMEZONE);\n    const todayParts = parseDateParts(todayStr);\n    if (!todayParts) {\n        return 'Failed to read store date';\n    }\n    const todayIndex = datePartsToIndex(todayParts);\n    const durationDays = endIndex - startIndex + 1;\n\n    if (startIndex < todayIndex + rules.leadTimeDays) {\n        return 'Start date violates lead time';\n    }\n    if (durationDays < rules.minDurationDays) {\n        return 'Below minimum duration';\n    }\n\n    return null;\n}\n\nasync function fetchLocationRules(\n    db: D1Database,\n    shopId: number,\n    locationCode: string\n): Promise<LocationRules | null> {\n    const row = await db\n        .prepare(\n            'SELECT lead_time_days, min_duration_days FROM locations WHERE shop_id = ? AND code = ? AND active = 1'\n        )\n        .bind(shopId, locationCode)\n        .first();\n    if (!isRecord(row)) {\n        return null;\n    }\n    const leadTimeDays = toNonNegativeInt(row.lead_time_days);\n    const minDurationDays = toPositiveInt(row.min_duration_days);\n    if (leadTimeDays === null || minDurationDays === null) {\n        return null;\n    }\n    return { leadTimeDays, minDurationDays };\n}\n\nfunction validateBookingItemsMatch(bookingItems: BookingItemRow[], lineItemKeyQty: Map<string, number>): string | null {\n    for (const item of bookingItems) {\n        const key = buildLineItemKey(item.product_id, item.variant_id);\n        const qty = lineItemKeyQty.get(key);\n        if (!qty) {\n            return `Missing line item for product ${item.product_id}`;\n        }\n        if (qty !== item.qty) {\n            return `Quantity mismatch for product ${item.product_id}`;\n        }\n    }\n    return null;\n}\n\nfunction validateDepositLineItems(\n    bookingItems: BookingItemRow[],\n    productMap: Map<number, ProductDepositRow>,\n    lineItemVariantQty: Map<number, number>\n): string | null {\n    const expectedByVariant = new Map<number, number>();\n    for (const item of bookingItems) {\n        const product = productMap.get(item.product_id);\n        if (!product) {\n            return `Product configuration missing for ${item.product_id}`;\n        }\n        if (!product.deposit_variant_id) {\n            continue;\n        }\n        const multiplier = normalizeDepositMultiplier(product.deposit_multiplier);\n        const expectedQty = item.qty * multiplier;\n        const current = expectedByVariant.get(product.deposit_variant_id) ?? 0;\n        expectedByVariant.set(product.deposit_variant_id, current + expectedQty);\n    }\n\n    for (const [variantId, expectedQty] of expectedByVariant.entries()) {\n        const actualQty = lineItemVariantQty.get(variantId) ?? 0;\n        if (actualQty !== expectedQty) {\n            return `Missing or mismatched deposit line item ${variantId}`;\n        }\n    }\n\n    return null;\n}\n\nfunction normalizeDepositMultiplier(value: number | null): number {\n    if (typeof value === 'number' && Number.isInteger(value) && value > 0) {\n        return value;\n    }\n    return 1;\n}\n\nfunction buildLineItemKeyMap(lineItems: OrderLineItem[]): Map<string, number> {\n    const map = new Map<string, number>();\n    for (const item of lineItems) {\n        if (!item.product_id || !item.variant_id) {\n            continue;\n        }\n        const key = buildLineItemKey(item.product_id, item.variant_id);\n        const qty = Number.isInteger(item.quantity) && item.quantity > 0 ? item.quantity : 0;\n        map.set(key, (map.get(key) ?? 0) + qty);\n    }\n    return map;\n}\n\nfunction buildLineItemVariantMap(lineItems: OrderLineItem[]): Map<number, number> {\n    const map = new Map<number, number>();\n    for (const item of lineItems) {\n        if (!item.variant_id) {\n            continue;\n        }\n        const qty = Number.isInteger(item.quantity) && item.quantity > 0 ? item.quantity : 0;\n        map.set(item.variant_id, (map.get(item.variant_id) ?? 0) + qty);\n    }\n    return map;\n}\n\nfunction buildLineItemKey(productId: number, variantId: number): string {\n    return `${productId}:${variantId}`;\n}\n\nfunction parseOrderPayload(rawBody: string): OrderWebhookPayload | null {\n    let data: unknown;\n    try {\n        data = JSON.parse(rawBody);\n    } catch (e) {\n        console.error('Failed to parse order payload JSON', e);\n        return null;\n    }\n\n    if (!isRecord(data)) {\n        return null;\n    }\n\n    const orderId = toPositiveInt(data.id);\n    if (!orderId) {\n        return null;\n    }\n\n    const lineItemsValue = data.line_items;\n    if (!Array.isArray(lineItemsValue)) {\n        return null;\n    }\n\n    const lineItems: OrderLineItem[] = [];\n    for (const value of lineItemsValue) {\n        const parsed = parseLineItem(value);\n        if (parsed) {\n            lineItems.push(parsed);\n        }\n    }\n\n    const email = readString(data.email);\n    const customer = isRecord(data.customer) ? {\n        first_name: readString(data.customer.first_name) || undefined,\n        last_name: readString(data.customer.last_name) || undefined,\n        email: readString(data.customer.email) || undefined\n    } : null;\n    const current_subtotal_price = readStringOrNumber(data.current_subtotal_price);\n    const noteAttributesValue = data.note_attributes;\n    const noteAttributes: OrderNoteAttribute[] = [];\n    if (Array.isArray(noteAttributesValue)) {\n        for (const entry of noteAttributesValue) {\n            if (!isRecord(entry)) {\n                continue;\n            }\n            const name = readString(entry.name);\n            const value = readStringOrNumber(entry.value);\n            if (!name || value === null) {\n                continue;\n            }\n            noteAttributes.push({ name, value });\n        }\n    }\n\n    return { id: orderId, line_items: lineItems, email, customer, current_subtotal_price, note_attributes: noteAttributes };\n}\n\nfunction parseLineItem(value: unknown): OrderLineItem | null {\n    if (!isRecord(value)) {\n        return null;\n    }\n\n    const productId = toPositiveInt(value.product_id);\n    const variantId = toPositiveInt(value.variant_id);\n    const quantity = toPositiveInt(value.quantity) ?? 0;\n    const price = readStringOrNumber(value.price);\n\n    let properties: OrderLineItem['properties'] = null;\n    if (Array.isArray(value.properties)) {\n        properties = value.properties as OrderLineItemProperty[];\n    } else if (isRecord(value.properties)) {\n        properties = value.properties;\n    }\n\n    return {\n        product_id: productId,\n        variant_id: variantId,\n        quantity,\n        price,\n        properties,\n    };\n}\n\nasync function linkAgreementSignature(\n    db: D1Database,\n    shopDomain: string,\n    orderId: number,\n    noteAttributes: OrderNoteAttribute[],\n    customerEmail: string\n): Promise<void> {\n    const agreementSignatureId = extractAgreementSignatureId(noteAttributes);\n    if (!agreementSignatureId) {\n        return;\n    }\n\n    const orderIdValue = orderId.toString();\n    const emailValue = customerEmail.trim() || null;\n\n    await db.prepare(\n        `UPDATE signed_agreements\n         SET order_id = ?,\n             status = 'linked_to_order',\n             customer_email = CASE\n                 WHEN customer_email IS NULL OR customer_email = '' THEN ?\n                 ELSE customer_email\n             END\n         WHERE shop_domain = ? AND id = ?`\n    )\n        .bind(orderIdValue, emailValue, shopDomain, agreementSignatureId)\n        .run();\n}\n\nfunction extractAgreementSignatureId(noteAttributes: OrderNoteAttribute[]): string | null {\n    for (const attr of noteAttributes) {\n        const name = normalizePropertyName(attr.name);\n        if (name === 'agreement_signature_id') {\n            if (typeof attr.value === 'number') {\n                return attr.value.toString();\n            }\n            if (typeof attr.value === 'string' && attr.value.trim()) {\n                return attr.value.trim();\n            }\n        }\n    }\n    return null;\n}\n\nfunction extractBookingTokens(lineItems: OrderLineItem[]): TokenExtractionResult {\n    const tokens = new Set<string>();\n    const lineItemsByToken = new Map<string, OrderLineItem[]>();\n    for (const item of lineItems) {\n        const token = extractBookingToken(item.properties);\n        if (!token) {\n            continue;\n        }\n        tokens.add(token);\n        const existing = lineItemsByToken.get(token);\n        if (existing) {\n            existing.push(item);\n        } else {\n            lineItemsByToken.set(token, [item]);\n        }\n    }\n    return { tokens: Array.from(tokens), lineItemsByToken };\n}\n\nfunction extractBookingToken(properties: OrderLineItem['properties']): string | null {\n    if (!properties) {\n        return null;\n    }\n\n    if (Array.isArray(properties)) {\n        for (const prop of properties) {\n            if (!isRecord(prop)) {\n                continue;\n            }\n            const name = readString(prop.name);\n            const value = readStringOrNumber(prop.value);\n            if (!name || !value) {\n                continue;\n            }\n            if (isBookingTokenProperty(name)) {\n                return value;\n            }\n        }\n        return null;\n    }\n\n    if (isRecord(properties)) {\n        for (const [key, value] of Object.entries(properties)) {\n            const name = readString(key);\n            const tokenValue = readStringOrNumber(value);\n            if (!name || !tokenValue) {\n                continue;\n            }\n            if (isBookingTokenProperty(name)) {\n                return tokenValue;\n            }\n        }\n    }\n\n    return null;\n}\n\nfunction isBookingTokenProperty(name: string): boolean {\n    return normalizePropertyName(name) === 'booking_token';\n}\n\nconst START_DATE_PROPERTY_KEYS = new Set(['start_date', 'booking_start_date']);\nconst END_DATE_PROPERTY_KEYS = new Set(['end_date', 'booking_end_date']);\nconst LOCATION_PROPERTY_KEYS = new Set(['location', 'booking_location']);\nconst FULFILLMENT_TYPE_KEYS = new Set(['fulfillment_type', 'fulfillment type']);\nconst DELIVERY_ADDRESS_KEYS = new Set(['delivery_address', 'delivery address']);\n\nfunction extractBookingMetaFromLineItems(lineItems: OrderLineItem[]): BookingLineItemMeta {\n    let startDate: string | null = null;\n    let endDate: string | null = null;\n    let location: string | null = null;\n    let fulfillmentType: string | null = null;\n    let deliveryAddress: string | null = null;\n\n    for (const item of lineItems) {\n        const meta = extractBookingMetaFromProperties(item.properties);\n        if (meta.error) {\n            return meta;\n        }\n        if (meta.startDate) {\n            if (startDate && startDate !== meta.startDate) {\n                return {\n                    startDate,\n                    endDate,\n                    location,\n                    error: 'Inconsistent booking start date across line items',\n                };\n            }\n            startDate = meta.startDate;\n        }\n        if (meta.endDate) {\n            if (endDate && endDate !== meta.endDate) {\n                return {\n                    startDate,\n                    endDate,\n                    location,\n                    error: 'Inconsistent booking end date across line items',\n                };\n            }\n            endDate = meta.endDate;\n        }\n        if (meta.location) {\n            if (location && location !== meta.location) {\n                return {\n                    startDate,\n                    endDate,\n                    location,\n                    error: 'Inconsistent booking location across line items',\n                };\n            }\n            location = meta.location;\n        }\n        if (meta.fulfillmentType) {\n            // We optimize for the first non-null value, or enforce consistency\n            if (fulfillmentType && fulfillmentType !== meta.fulfillmentType) {\n                // Warn but maybe don't fail? Let's be strict for now.\n            }\n            fulfillmentType = meta.fulfillmentType;\n        }\n        if (meta.deliveryAddress) {\n            deliveryAddress = meta.deliveryAddress;\n        }\n    }\n\n    return { startDate, endDate, location, fulfillmentType, deliveryAddress };\n}\n\nfunction extractBookingMetaFromProperties(properties: OrderLineItem['properties']): BookingLineItemMeta {\n    let startDate: string | null = null;\n    let endDate: string | null = null;\n    let location: string | null = null;\n    let fulfillmentType: string | null = null;\n    let deliveryAddress: string | null = null;\n\n    if (!properties) {\n        return { startDate, endDate, location };\n    }\n\n    const applyValue = (name: string, value: string): string | null => {\n        const normalized = normalizePropertyName(name);\n        if (START_DATE_PROPERTY_KEYS.has(normalized)) {\n            if (startDate && startDate !== value) {\n                return 'Conflicting booking start date in line item properties';\n            }\n            startDate = value;\n        } else if (END_DATE_PROPERTY_KEYS.has(normalized)) {\n            if (endDate && endDate !== value) {\n                return 'Conflicting booking end date in line item properties';\n            }\n            endDate = value;\n        } else if (LOCATION_PROPERTY_KEYS.has(normalized)) {\n            if (location && location !== value) {\n                return 'Conflicting booking location in line item properties';\n            }\n            location = value;\n        } else if (FULFILLMENT_TYPE_KEYS.has(normalized)) {\n            fulfillmentType = value;\n        } else if (DELIVERY_ADDRESS_KEYS.has(normalized)) {\n            deliveryAddress = value;\n        }\n        return null;\n    };\n\n    if (Array.isArray(properties)) {\n        for (const prop of properties) {\n            if (!isRecord(prop)) {\n                continue;\n            }\n            const name = readString(prop.name);\n            const value = readStringOrNumber(prop.value);\n            if (!name || !value) {\n                continue;\n            }\n            const error = applyValue(name, value);\n            if (error) {\n                return { startDate, endDate, location, error };\n            }\n        }\n        return { startDate, endDate, location };\n    }\n\n    if (isRecord(properties)) {\n        for (const [key, rawValue] of Object.entries(properties)) {\n            const name = readString(key);\n            const value = readStringOrNumber(rawValue);\n            if (!name || !value) {\n                continue;\n            }\n            const error = applyValue(name, value);\n            if (error) {\n                return { startDate, endDate, location, error };\n            }\n        }\n    }\n\n    return { startDate, endDate, location, fulfillmentType, deliveryAddress };\n}\n\nfunction normalizePropertyName(name: string): string {\n    return name.trim().toLowerCase().replace(/\\s+/g, '_').replace(/^_+/, '');\n}\n\nfunction parseBookingDetailRow(row: unknown): BookingDetailRow | null {\n    if (!isRecord(row)) {\n        return null;\n    }\n    const id = readString(row.id);\n    const shopId = toPositiveInt(row.shop_id);\n    const status = readBookingStatus(row.status);\n    const orderId = toPositiveInt(row.order_id);\n    const startDate = readString(row.start_date);\n    const endDate = readString(row.end_date);\n    const locationCode = readString(row.location_code);\n    if (!id || !shopId || !status || !startDate || !endDate || !locationCode) {\n        return null;\n    }\n    return {\n        id,\n        shop_id: shopId,\n        status,\n        order_id: orderId ?? null,\n        start_date: startDate,\n        end_date: endDate,\n        location_code: locationCode,\n    };\n}\n\nfunction parseShopAuthRow(row: unknown): ShopAuthRow | null {\n    if (!isRecord(row)) {\n        return null;\n    }\n    const shopDomain = readString(row.shop_domain);\n    const accessToken = readString(row.access_token);\n    if (!shopDomain || !accessToken) {\n        return null;\n    }\n    return { shop_domain: shopDomain, access_token: accessToken };\n}\n\nfunction parseBookingStatusRow(row: unknown): { status: BookingStatus; order_id: number | null } | null {\n    if (!isRecord(row)) {\n        return null;\n    }\n    const status = readBookingStatus(row.status);\n    if (!status) {\n        return null;\n    }\n    const orderId = toPositiveInt(row.order_id);\n    return { status, order_id: orderId ?? null };\n}\n\nfunction normalizeBookingItems(rows: unknown[]): BookingItemRow[] {\n    const items: BookingItemRow[] = [];\n    for (const row of rows) {\n        if (!isRecord(row)) {\n            continue;\n        }\n        const productId = toPositiveInt(row.product_id);\n        const variantId = toPositiveInt(row.variant_id);\n        const qty = toPositiveInt(row.qty);\n        if (!productId || !variantId || !qty) {\n            continue;\n        }\n        items.push({ product_id: productId, variant_id: variantId, qty });\n    }\n    return items;\n}\n\nfunction normalizeProductDeposits(rows: unknown[]): ProductDepositRow[] {\n    const items: ProductDepositRow[] = [];\n    for (const row of rows) {\n        if (!isRecord(row)) {\n            continue;\n        }\n        const productId = toPositiveInt(row.product_id);\n        if (!productId) {\n            continue;\n        }\n        const depositVariantId = toPositiveInt(row.deposit_variant_id);\n        const multiplier = toPositiveInt(row.deposit_multiplier);\n        items.push({\n            product_id: productId,\n            deposit_variant_id: depositVariantId ?? null,\n            deposit_multiplier: multiplier ?? null,\n        });\n    }\n    return items;\n}\n\nasync function deleteWebhookEvent(db: D1Database, shopId: number, eventId: string): Promise<void> {\n    try {\n        await db\n            .prepare('DELETE FROM webhook_events WHERE shop_id = ? AND event_id = ?')\n            .bind(shopId, eventId)\n            .run();\n    } catch (e) {\n        console.error('Failed to cleanup webhook event', e);\n    }\n}\n\nfunction readString(value: unknown): string | null {\n    if (typeof value === 'string') {\n        const trimmed = value.trim();\n        return trimmed ? trimmed : null;\n    }\n    return null;\n}\n\nfunction readStringOrNumber(value: unknown): string | null {\n    if (typeof value === 'string') {\n        const trimmed = value.trim();\n        return trimmed ? trimmed : null;\n    }\n    if (typeof value === 'number' && Number.isFinite(value)) {\n        return String(value);\n    }\n    return null;\n}\n\nfunction readBookingStatus(value: unknown): BookingStatus | null {\n    if (typeof value !== 'string') {\n        return null;\n    }\n    switch (value) {\n        case 'HOLD':\n        case 'CONFIRMED':\n        case 'RELEASED':\n        case 'EXPIRED':\n        case 'INVALID':\n        case 'CANCELLED':\n            return value;\n        default:\n            return null;\n    }\n}\n\nfunction toPositiveInt(value: unknown): number | null {\n    const parsed =\n        typeof value === 'number'\n            ? value\n            : typeof value === 'string' && value.trim() !== ''\n                ? Number(value)\n                : NaN;\n    if (!Number.isInteger(parsed) || parsed <= 0) {\n        return null;\n    }\n    return parsed;\n}\n\nfunction toNonNegativeInt(value: unknown): number | null {\n    const parsed =\n        typeof value === 'number'\n            ? value\n            : typeof value === 'string' && value.trim() !== ''\n                ? Number(value)\n                : NaN;\n    if (!Number.isInteger(parsed) || parsed < 0) {\n        return null;\n    }\n    return parsed;\n}\n\nfunction isRecord(value: unknown): value is Record<string, unknown> {\n    return typeof value === 'object' && value !== null;\n}\nfunction calculateBookingRevenue(lineItems: OrderLineItem[]): number {\n    let total = 0;\n    for (const item of lineItems) {\n        const price = parseFloat(item.price || '0');\n        if (!isNaN(price)) {\n            total += price * item.quantity;\n        }\n    }\n    return total;\n}\n", "import { confirmBookingsFromOrder } from './bookingService';\nimport { Env } from './types';\n\nexport async function handleWebhook(request: Request, env: Env): Promise<Response> {\n    const topic = request.headers.get('X-Shopify-Topic');\n    const hmac = request.headers.get('X-Shopify-Hmac-Sha256');\n    const shopDomain = request.headers.get('X-Shopify-Shop-Domain');\n    const eventId = request.headers.get('X-Shopify-Webhook-Id');\n\n    if (!topic || !hmac || !shopDomain || !eventId) {\n        console.error('Missing webhook headers');\n        return new Response('Missing webhook headers', { status: 400 });\n    }\n\n    const rawBody = await request.text();\n    const valid = await verifyWebhookHmac(rawBody, hmac, env.SHOPIFY_API_SECRET);\n\n    if (!valid) {\n        console.error('Invalid webhook HMAC');\n        return new Response('Invalid webhook HMAC', { status: 401 });\n    }\n\n    // Process specific topics\n    try {\n        if (topic === 'app/uninstalled') {\n            await handleAppUninstalled(shopDomain, env);\n        } else if (topic === 'orders/create') {\n            const result = await confirmBookingsFromOrder(env, shopDomain, eventId, topic, rawBody);\n            return new Response(result.body, { status: result.status });\n        } else {\n            console.log('Unhandled webhook topic', topic);\n        }\n    } catch (e) {\n        console.error('Error processing webhook', e);\n        return new Response('Internal Server Error', { status: 500 });\n    }\n\n    return new Response('Webhook processed');\n}\n\nasync function handleAppUninstalled(shopDomain: string, env: Env) {\n    console.log(`Processing app/uninstalled for ${shopDomain}`);\n    try {\n        await env.DB.prepare(\n            `UPDATE shops SET uninstalled_at = datetime('now'), access_token = NULL WHERE shop_domain = ?`\n        )\n            .bind(shopDomain)\n            .run();\n        console.log(`Shop processed uninstall: ${shopDomain}`);\n    } catch (e) {\n        console.error('Database error during uninstall', e);\n        throw e;\n    }\n}\n\nasync function verifyWebhookHmac(body: string, hmac: string, secret: string): Promise<boolean> {\n    const encoder = new TextEncoder();\n    const keyData = encoder.encode(secret);\n    const data = encoder.encode(body);\n\n    const key = await crypto.subtle.importKey(\n        'raw',\n        keyData,\n        { name: 'HMAC', hash: 'SHA-256' },\n        false,\n        ['verify']\n    );\n\n    const signature = new Uint8Array(\n        atob(hmac).split('').map((c) => c.charCodeAt(0))\n    );\n\n    return await crypto.subtle.verify('HMAC', key, signature, data);\n}\n", "interface RateLimitState {\n    count: number;\n    resetAt: number;\n}\n\nexport interface RateLimitResult {\n    allowed: boolean;\n    remaining: number;\n    resetAt: number;\n}\n\nconst store = new Map<string, RateLimitState>();\n\nexport function checkRateLimit(key: string, max: number, windowMs: number): RateLimitResult {\n    const now = Date.now();\n    const existing = store.get(key);\n    if (!existing || now >= existing.resetAt) {\n        const resetAt = now + windowMs;\n        store.set(key, { count: 1, resetAt });\n        return { allowed: true, remaining: max - 1, resetAt };\n    }\n\n    if (existing.count >= max) {\n        return { allowed: false, remaining: 0, resetAt: existing.resetAt };\n    }\n\n    existing.count += 1;\n    store.set(key, existing);\n    return { allowed: true, remaining: max - existing.count, resetAt: existing.resetAt };\n}\n", "import { Env } from './types';\nimport { verifyProxySignature } from './security';\nimport { checkRateLimit } from './rateLimit';\nimport { releaseBooking } from './bookingService';\nimport {\n    datePartsToIndex,\n    getTodayInTimeZone,\n    listDateStrings,\n    parseDateParts,\n} from './date';\nimport { STORE_TIMEZONE } from './config';\n\ninterface AvailabilityResponse {\n    ok: boolean;\n    available?: boolean;\n    min_available_qty?: number;\n    details?: string;\n    error?: string;\n}\n\ninterface LocationRules {\n    leadTimeDays: number;\n    minDurationDays: number;\n}\n\ninterface HoldRequestItemInput {\n    product_id: number;\n    variant_id?: number;\n    qty: number;\n}\n\ninterface HoldRequestBody {\n    start_date: string;\n    end_date: string;\n    location: string;\n    items: HoldRequestItemInput[];\n}\n\ninterface ReleaseRequestBody {\n    booking_token: string;\n}\n\ninterface NormalizedHoldItem {\n    product_id: number;\n    variant_id: number;\n    qty: number;\n    default_capacity: number;\n}\n\nconst HOLD_MINUTES = 20;\n\nexport async function handleProxyRequest(request: Request, env: Env): Promise<Response> {\n    const url = new URL(request.url);\n    const shop = url.searchParams.get('shop');\n\n    const corsHeaders = {\n        'Access-Control-Allow-Origin': '*',\n        'Access-Control-Allow-Methods': 'GET, POST, OPTIONS',\n        'Access-Control-Allow-Headers': 'Content-Type',\n    };\n\n    const rate = checkRateLimit(rateLimitKey(request, 'proxy'), 240, 60_000);\n    if (!rate.allowed) {\n        return new Response('Rate limit exceeded', {\n            status: 429,\n            headers: {\n                ...corsHeaders,\n                ...rateLimitResponse(rate.resetAt).headers\n            }\n        });\n    }\n\n    const isAgreementSign = url.pathname.endsWith('/agreement/sign');\n    const isDev = env.ENVIRONMENT === 'dev';\n    if (isAgreementSign && !isDev) {\n        const valid = await verifyProxySignature(request, env.SHOPIFY_API_SECRET);\n        if (!valid) {\n            return new Response('Invalid signature', { status: 401, headers: corsHeaders });\n        }\n    }\n\n    if (!shop) {\n        return new Response('Missing shop parameter', { status: 400, headers: corsHeaders });\n    }\n\n    let response: Response;\n    if (url.pathname.endsWith('/availability')) {\n        response = await handleAvailability(request, env, shop);\n    } else if (url.pathname.endsWith('/hold')) {\n        if (request.method.toUpperCase() !== 'POST') {\n            response = new Response('Method Not Allowed', { status: 405 });\n        } else {\n            response = await handleHold(request, env, shop);\n        }\n    } else if (url.pathname.endsWith('/release')) {\n        if (request.method.toUpperCase() !== 'POST') {\n            response = new Response('Method Not Allowed', { status: 405 });\n        } else {\n            response = await handleRelease(request, env, shop);\n        }\n    } else if (url.pathname.endsWith('/config')) {\n        if (request.method.toUpperCase() !== 'GET') {\n            response = new Response('Method Not Allowed', { status: 405 });\n        } else {\n            response = await handleConfig(env, shop);\n        }\n    } else if (url.pathname.endsWith('/agreement/current')) {\n        if (request.method.toUpperCase() !== 'GET') {\n            response = new Response('Method Not Allowed', { status: 405 });\n        } else {\n            response = await handleAgreementCurrent(env, shop);\n        }\n    } else if (url.pathname.endsWith('/agreement/sign')) {\n        if (request.method.toUpperCase() !== 'POST') {\n            response = new Response('Method Not Allowed', { status: 405 });\n        } else {\n            response = await handleAgreementSign(request, env, shop);\n        }\n    } else {\n        response = new Response('Not Found', { status: 404 });\n    }\n\n    // Append CORS headers to whatever response we got\n    const newHeaders = new Headers(response.headers);\n    Object.entries(corsHeaders).forEach(([k, v]) => newHeaders.set(k, v));\n\n    return new Response(response.body, {\n        status: response.status,\n        statusText: response.statusText,\n        headers: newHeaders\n    });\n}\n\nasync function handleAvailability(request: Request, env: Env, shopDomain: string): Promise<Response> {\n    const url = new URL(request.url);\n    const startDateStr = url.searchParams.get('start_date');\n    const endDateStr = url.searchParams.get('end_date');\n    const locationCode = url.searchParams.get('location');\n    const quantityStr = url.searchParams.get('quantity');\n    const productIdStr = url.searchParams.get('product_id');\n\n    // Validation\n    if (!startDateStr || !endDateStr || !quantityStr || !productIdStr) {\n        return Response.json({ ok: false, error: 'Missing required parameters' }, { status: 400 });\n    }\n\n    const quantity = Number(quantityStr);\n    const productId = Number(productIdStr);\n\n    if (!Number.isInteger(quantity) || quantity < 1) {\n        return Response.json({ ok: false, error: 'Invalid quantity' }, { status: 400 });\n    }\n\n    if (!Number.isInteger(productId) || productId <= 0) {\n        return Response.json({ ok: false, error: 'Invalid product id' }, { status: 400 });\n    }\n\n    const startParts = parseDateParts(startDateStr);\n    const endParts = parseDateParts(endDateStr);\n    if (!startParts || !endParts) {\n        return Response.json({ ok: false, error: 'Invalid dates' }, { status: 400 });\n    }\n\n    const startIndex = datePartsToIndex(startParts);\n    const endIndex = datePartsToIndex(endParts);\n    if (startIndex > endIndex) {\n        return Response.json({ ok: false, error: 'Start date must be before end date' }, { status: 400 });\n    }\n\n    try {\n        const shopStmt = await env.DB.prepare('SELECT id FROM shops WHERE shop_domain = ?')\n            .bind(shopDomain)\n            .first();\n        if (!shopStmt) {\n            return Response.json({ ok: false, error: 'Shop not found' }, { status: 404 });\n        }\n        const shopId = shopStmt.id as number;\n\n        if (locationCode) {\n            const locStmt = await env.DB.prepare(\n                'SELECT id, lead_time_days, min_duration_days FROM locations WHERE shop_id = ? AND code = ? AND active = 1'\n            )\n                .bind(shopId, locationCode)\n                .first();\n            if (!locStmt) {\n                return Response.json({ ok: false, error: 'Invalid location' }, { status: 400 });\n            }\n\n            const todayStr = getTodayInTimeZone(STORE_TIMEZONE);\n            const todayParts = parseDateParts(todayStr);\n            if (!todayParts) {\n                return Response.json({ ok: false, error: 'Failed to read store date' }, { status: 500 });\n            }\n            const todayIndex = datePartsToIndex(todayParts);\n            const leadTimeDays = locStmt.lead_time_days as number;\n            const minDurationDays = locStmt.min_duration_days as number;\n            const durationDays = endIndex - startIndex + 1;\n\n            if (startIndex < todayIndex + leadTimeDays) {\n                return Response.json({ ok: false, error: 'Start date violates lead time' }, { status: 400 });\n            }\n            if (durationDays < minDurationDays) {\n                return Response.json({ ok: false, error: 'Below minimum duration' }, { status: 400 });\n            }\n        }\n\n        const productStmt = await env.DB.prepare(\n            'SELECT default_capacity, rentable FROM products WHERE shop_id = ? AND product_id = ?'\n        )\n            .bind(shopId, productId)\n            .first();\n\n        if (!productStmt) {\n            return Response.json({ ok: false, error: 'Product not configured for borrowing' }, { status: 404 });\n        }\n\n        if (!productStmt.rentable) {\n            return Response.json({ ok: false, error: 'Product is not rentable' }, { status: 400 });\n        }\n\n        const defaultCapacity = productStmt.default_capacity as number;\n        const dateList = listDateStrings(startDateStr, endDateStr);\n        if (!dateList) {\n            return Response.json({ ok: false, error: 'Invalid date range' }, { status: 400 });\n        }\n\n        const inventoryRows = await env.DB.prepare(\n            'SELECT date, capacity, reserved_qty FROM inventory_day WHERE shop_id = ? AND product_id = ? AND date >= ? AND date <= ?'\n        )\n            .bind(shopId, productId, startDateStr, endDateStr)\n            .all();\n\n        const inventoryMap = new Map<string, { capacity: number; reserved: number }>();\n        if (inventoryRows.results) {\n            for (const row of inventoryRows.results) {\n                inventoryMap.set(row.date as string, {\n                    capacity: row.capacity as number,\n                    reserved: row.reserved_qty as number,\n                });\n            }\n        }\n\n        let minAvailable = Infinity;\n        for (const dateStr of dateList) {\n            let cap = defaultCapacity;\n            let res = 0;\n\n            if (inventoryMap.has(dateStr)) {\n                const data = inventoryMap.get(dateStr)!;\n                cap = data.capacity;\n                res = data.reserved;\n            }\n\n            const avail = cap - res;\n            if (avail < minAvailable) {\n                minAvailable = avail;\n            }\n        }\n\n        const isAvailable = minAvailable >= quantity;\n\n        return Response.json({\n            ok: true,\n            available: isAvailable,\n            min_available_qty: minAvailable,\n        } satisfies AvailabilityResponse);\n    } catch (e) {\n        console.error('Availability check failed', e);\n        return Response.json({ ok: false, error: 'Internal Server Error' }, { status: 500 });\n    }\n}\n\nasync function handleHold(request: Request, env: Env, shopDomain: string): Promise<Response> {\n    const body = await readJsonBody(request);\n    if (!body) {\n        return Response.json({ ok: false, error: 'Invalid JSON body' }, { status: 400 });\n    }\n\n    const parsed = parseHoldBody(body);\n    if (!parsed) {\n        return Response.json({ ok: false, error: 'Invalid hold request' }, { status: 400 });\n    }\n\n    try {\n        const shopStmt = await env.DB.prepare('SELECT id FROM shops WHERE shop_domain = ?')\n            .bind(shopDomain)\n            .first();\n        if (!shopStmt) {\n            return Response.json({ ok: false, error: 'Shop not found' }, { status: 404 });\n        }\n        const shopId = shopStmt.id as number;\n\n        const location = await env.DB.prepare(\n            'SELECT code, lead_time_days, min_duration_days FROM locations WHERE shop_id = ? AND code = ? AND active = 1'\n        )\n            .bind(shopId, parsed.location)\n            .first();\n        if (!location) {\n            return Response.json({ ok: false, error: 'Invalid location' }, { status: 400 });\n        }\n\n        const startParts = parseDateParts(parsed.start_date);\n        const endParts = parseDateParts(parsed.end_date);\n        if (!startParts || !endParts) {\n            return Response.json({ ok: false, error: 'Invalid dates' }, { status: 400 });\n        }\n        const startIndex = datePartsToIndex(startParts);\n        const endIndex = datePartsToIndex(endParts);\n        if (startIndex > endIndex) {\n            return Response.json({ ok: false, error: 'Start date must be before end date' }, { status: 400 });\n        }\n\n        const todayStr = getTodayInTimeZone(STORE_TIMEZONE);\n        const todayParts = parseDateParts(todayStr);\n        if (!todayParts) {\n            return Response.json({ ok: false, error: 'Failed to read store date' }, { status: 500 });\n        }\n        const todayIndex = datePartsToIndex(todayParts);\n        const leadTimeDays = location.lead_time_days as number;\n        const minDurationDays = location.min_duration_days as number;\n        const durationDays = endIndex - startIndex + 1;\n\n        if (startIndex < todayIndex + leadTimeDays) {\n            return Response.json({ ok: false, error: 'Start date violates lead time' }, { status: 400 });\n        }\n        if (durationDays < minDurationDays) {\n            return Response.json({ ok: false, error: 'Below minimum duration' }, { status: 400 });\n        }\n\n        const uniqueProductIds = Array.from(new Set(parsed.items.map((item) => item.product_id)));\n        const placeholders = uniqueProductIds.map(() => '?').join(', ');\n        const productRows = await env.DB.prepare(\n            `SELECT product_id, variant_id, rentable, default_capacity FROM products WHERE shop_id = ? AND product_id IN (${placeholders})`\n        )\n            .bind(shopId, ...uniqueProductIds)\n            .all();\n\n        const productMap = new Map<number, { variant_id: number | null; rentable: number; default_capacity: number }>();\n        for (const row of productRows.results ?? []) {\n            productMap.set(row.product_id as number, {\n                variant_id: row.variant_id as number | null,\n                rentable: row.rentable as number,\n                default_capacity: row.default_capacity as number,\n            });\n        }\n\n        const normalizedItems = normalizeHoldItems(parsed.items, productMap);\n        if (!normalizedItems) {\n            return Response.json({ ok: false, error: 'Invalid product configuration' }, { status: 400 });\n        }\n\n        const dateList = listDateStrings(parsed.start_date, parsed.end_date);\n        if (!dateList) {\n            return Response.json({ ok: false, error: 'Invalid date range' }, { status: 400 });\n        }\n\n        const bookingId = crypto.randomUUID();\n        const bookingToken = crypto.randomUUID();\n        const expiresAt = new Date(Date.now() + HOLD_MINUTES * 60 * 1000).toISOString();\n\n        const statements: D1PreparedStatement[] = [];\n        statements.push(\n            env.DB.prepare(\n                `INSERT INTO bookings (id, shop_id, booking_token, status, location_code, start_date, end_date, expires_at, created_at, updated_at)\n                 VALUES (?, ?, ?, 'HOLD', ?, ?, ?, ?, datetime('now'), datetime('now'))`\n            ).bind(bookingId, shopId, bookingToken, parsed.location, parsed.start_date, parsed.end_date, expiresAt)\n        );\n\n        for (const item of normalizedItems) {\n            statements.push(\n                env.DB.prepare(\n                    `INSERT INTO booking_items (booking_id, product_id, variant_id, qty)\n                     VALUES (?, ?, ?, ?)`\n                ).bind(bookingId, item.product_id, item.variant_id, item.qty)\n            );\n        }\n\n        for (const date of dateList) {\n            for (const item of normalizedItems) {\n                statements.push(\n                    env.DB.prepare(\n                        `INSERT OR IGNORE INTO inventory_day (shop_id, product_id, date, capacity, reserved_qty)\n                         VALUES (?, ?, ?, ?, 0)`\n                    ).bind(shopId, item.product_id, date, item.default_capacity)\n                );\n                statements.push(\n                    env.DB.prepare(\n                        `UPDATE inventory_day\n                         SET reserved_qty = reserved_qty + ?\n                         WHERE shop_id = ? AND product_id = ? AND date = ? AND reserved_qty + ? <= capacity`\n                    ).bind(item.qty, shopId, item.product_id, date, item.qty)\n                );\n                statements.push(env.DB.prepare('SELECT CASE WHEN changes() = 1 THEN 1 ELSE 1/0 END;'));\n                statements.push(\n                    env.DB.prepare(\n                        `INSERT INTO booking_days (booking_id, product_id, date, qty)\n                         VALUES (?, ?, ?, ?)`\n                    ).bind(bookingId, item.product_id, date, item.qty)\n                );\n            }\n        }\n\n        await env.DB.batch(statements);\n\n        return Response.json({\n            ok: true,\n            booking_token: bookingToken,\n            expires_at: expiresAt,\n        });\n    } catch (e) {\n        console.error('Hold failed', e);\n        if (String(e).includes('division')) {\n            return Response.json({ ok: false, error: 'Insufficient capacity' }, { status: 409 });\n        }\n        return Response.json({ ok: false, error: 'Internal Server Error' }, { status: 500 });\n    }\n}\n\nasync function handleRelease(request: Request, env: Env, shopDomain: string): Promise<Response> {\n    const body = await readJsonBody(request);\n    if (!body) {\n        return Response.json({ ok: false, error: 'Invalid JSON body' }, { status: 400 });\n    }\n\n    const token = getString(body, 'booking_token');\n    if (!token) {\n        return Response.json({ ok: false, error: 'Missing booking token' }, { status: 400 });\n    }\n\n    try {\n        const shopStmt = await env.DB.prepare('SELECT id FROM shops WHERE shop_domain = ?')\n            .bind(shopDomain)\n            .first();\n        if (!shopStmt) {\n            return Response.json({ ok: false, error: 'Shop not found' }, { status: 404 });\n        }\n        const shopId = shopStmt.id as number;\n\n        const booking = await env.DB.prepare(\n            'SELECT id, status FROM bookings WHERE shop_id = ? AND booking_token = ?'\n        )\n            .bind(shopId, token)\n            .first();\n        if (!booking) {\n            return Response.json({ ok: false, error: 'Booking not found' }, { status: 404 });\n        }\n\n        if (booking.status !== 'HOLD') {\n            return Response.json({ ok: true, status: booking.status });\n        }\n\n        await releaseBooking(env.DB, booking.id as string, 'RELEASED');\n\n        return Response.json({ ok: true, status: 'RELEASED' });\n    } catch (e) {\n        console.error('Release failed', e);\n        return Response.json({ ok: false, error: 'Internal Server Error' }, { status: 500 });\n    }\n}\n\nasync function handleConfig(env: Env, shopDomain: string): Promise<Response> {\n    try {\n        const shopStmt = await env.DB.prepare('SELECT id, shop_domain, access_token FROM shops WHERE shop_domain = ?')\n            .bind(shopDomain)\n            .first();\n        if (!shopStmt) {\n            return Response.json({ ok: false, error: 'Shop not found' }, { status: 404 });\n        }\n        const shopId = shopStmt.id as number;\n        const accessToken = shopStmt.access_token as string;\n\n        const locations = await env.DB.prepare(\n            'SELECT code, name, lead_time_days, min_duration_days FROM locations WHERE shop_id = ? AND active = 1 ORDER BY name'\n        )\n            .bind(shopId)\n            .all();\n\n        const productsRows = await env.DB.prepare(\n            'SELECT product_id, variant_id, default_capacity, deposit_variant_id, deposit_multiplier FROM products WHERE shop_id = ? AND rentable = 1 ORDER BY product_id'\n        )\n            .bind(shopId)\n            .all();\n\n        const products = productsRows.results ?? [];\n\n        // Fetch product details from Shopify if we have products\n        if (products.length > 0) {\n            const productIds = products.map((p: any) => `gid://shopify/Product/${p.product_id}`);\n            const query = `\n            query ($ids: [ID!]!) {\n              nodes(ids: $ids) {\n                ... on Product {\n                  id\n                  title\n                }\n              }\n            }\n            `;\n\n            try {\n                const shopifyRes = await fetch(`https://${shopDomain}/admin/api/2025-10/graphql.json`, {\n                    method: 'POST',\n                    headers: {\n                        'X-Shopify-Access-Token': accessToken,\n                        'Content-Type': 'application/json',\n                    },\n                    body: JSON.stringify({\n                        query,\n                        variables: { ids: productIds }\n                    }),\n                });\n\n                if (shopifyRes.ok) {\n                    const shopifyData = await shopifyRes.json() as any;\n                    const nodes = shopifyData.data?.nodes || [];\n\n                    // Create map of ID -> Title\n                    const titleMap = new Map<number, string>();\n                    nodes.forEach((node: any) => {\n                        if (node && node.id) {\n                            const id = parseInt(node.id.split('/').pop() || '0');\n                            titleMap.set(id, node.title);\n                        }\n                    });\n\n                    // Merge titles into products\n                    products.forEach((p: any) => {\n                        p.title = titleMap.get(p.product_id) || `Product ${p.product_id}`;\n                    });\n                } else {\n                    console.error('Failed to fetch Shopify products', await shopifyRes.text());\n                }\n            } catch (err) {\n                console.error('Error fetching Shopify products', err);\n            }\n        }\n\n        return Response.json({\n            ok: true,\n            locations: locations.results ?? [],\n            products: products,\n        });\n    } catch (e) {\n        console.error('Config fetch failed', e);\n        return Response.json({ ok: false, error: 'Internal Server Error' }, { status: 500 });\n    }\n}\n\ninterface AgreementPublicResponse {\n    id: string;\n    version: number;\n    title: string | null;\n    pdf_url: string;\n    pdf_storage_type: string;\n    pdf_sha256: string | null;\n    page_number: number;\n    x: number;\n    y: number;\n    width: number;\n    height: number;\n}\n\nasync function handleAgreementCurrent(env: Env, shopDomain: string): Promise<Response> {\n    try {\n        const shopStmt = await env.DB.prepare('SELECT id FROM shops WHERE shop_domain = ?')\n            .bind(shopDomain)\n            .first();\n        if (!shopStmt) {\n            return Response.json({ ok: false, error: 'Shop not found' }, { status: 404 });\n        }\n        const shopId = shopStmt.id as number;\n\n        const agreementRow = await env.DB.prepare(\n            `SELECT id, version, title, pdf_storage_type, pdf_storage_key, pdf_sha256,\n                    page_number, x, y, width, height\n             FROM agreements\n             WHERE shop_domain = ? AND active = 1\n             ORDER BY version DESC\n             LIMIT 1`\n        )\n            .bind(shopDomain)\n            .first();\n\n        const productsRows = await env.DB.prepare(\n            'SELECT product_id FROM products WHERE shop_id = ? AND rentable = 1 ORDER BY product_id'\n        )\n            .bind(shopId)\n            .all();\n        const rentableProductIds = (productsRows.results ?? [])\n            .filter(isRecord)\n            .map((row) => toNumber(row.product_id))\n            .filter((value): value is number => typeof value === 'number');\n\n        if (!agreementRow || !isRecord(agreementRow)) {\n            return Response.json({ ok: true, agreement: null, rentable_product_ids: rentableProductIds });\n        }\n\n        const agreement = mapAgreementPublicRow(agreementRow);\n        if (!agreement) {\n            return Response.json({ ok: false, error: 'Agreement data invalid' }, { status: 500 });\n        }\n\n        return Response.json({ ok: true, agreement, rentable_product_ids: rentableProductIds });\n    } catch (e) {\n        console.error('Agreement current failed', e);\n        return Response.json({ ok: false, error: 'Internal Server Error' }, { status: 500 });\n    }\n}\n\nasync function handleAgreementSign(request: Request, env: Env, shopDomain: string): Promise<Response> {\n    const body = await readJsonBody(request);\n    if (!body) {\n        return Response.json({ ok: false, error: 'Invalid JSON body' }, { status: 400 });\n    }\n\n    const cartToken = getString(body, 'cart_token');\n    const agreementId = getString(body, 'agreement_id');\n    const signatureDataUrl = getString(body, 'signature_data_url');\n\n    if (!cartToken || !agreementId || !signatureDataUrl) {\n        return Response.json({ ok: false, error: 'Missing required fields' }, { status: 400 });\n    }\n\n    if (!isPngDataUrl(signatureDataUrl)) {\n        return Response.json({ ok: false, error: 'Signature must be a PNG data URL' }, { status: 400 });\n    }\n\n    try {\n        const agreementRow = await env.DB.prepare(\n            'SELECT id FROM agreements WHERE shop_domain = ? AND id = ? AND active = 1'\n        )\n            .bind(shopDomain, agreementId)\n            .first();\n\n        if (!agreementRow) {\n            return Response.json({ ok: false, error: 'Agreement not found' }, { status: 404 });\n        }\n\n        const signedId = crypto.randomUUID();\n        const signedAt = new Date().toISOString();\n\n        await env.DB.prepare(\n            `INSERT INTO signed_agreements (\n                id, shop_domain, agreement_id, cart_token, signature_png_base64, signed_at, status\n            )\n            VALUES (?, ?, ?, ?, ?, ?, 'pending')`\n        )\n            .bind(signedId, shopDomain, agreementId, cartToken, signatureDataUrl, signedAt)\n            .run();\n\n        return Response.json({ ok: true, signed_agreement_id: signedId });\n    } catch (e) {\n        console.error('Agreement sign failed', e);\n        return Response.json({ ok: false, error: 'Internal Server Error' }, { status: 500 });\n    }\n}\n\nfunction mapAgreementPublicRow(row: Record<string, unknown>): AgreementPublicResponse | null {\n    const id = readStringField(row, 'id');\n    const pdfStorageKey = readStringField(row, 'pdf_storage_key');\n    const pdfStorageType = readStringField(row, 'pdf_storage_type');\n    if (!id || !pdfStorageKey || !pdfStorageType) {\n        return null;\n    }\n\n    const version = toNumber(row.version);\n    const pageNumber = toNumber(row.page_number);\n    const x = toNumber(row.x);\n    const y = toNumber(row.y);\n    const width = toNumber(row.width);\n    const height = toNumber(row.height);\n\n    if (\n        version === null ||\n        pageNumber === null ||\n        x === null ||\n        y === null ||\n        width === null ||\n        height === null\n    ) {\n        return null;\n    }\n\n    return {\n        id,\n        version,\n        title: readStringField(row, 'title'),\n        pdf_url: pdfStorageKey,\n        pdf_storage_type: pdfStorageType,\n        pdf_sha256: readStringField(row, 'pdf_sha256'),\n        page_number: pageNumber,\n        x,\n        y,\n        width,\n        height\n    };\n}\n\nfunction normalizeHoldItems(\n    items: HoldRequestItemInput[],\n    productMap: Map<number, { variant_id: number | null; rentable: number; default_capacity: number }>\n): NormalizedHoldItem[] | null {\n    const map = new Map<number, NormalizedHoldItem>();\n\n    for (const item of items) {\n        const product = productMap.get(item.product_id);\n        if (!product || !product.rentable) {\n            return null;\n        }\n\n        const defaultCapacity = product.default_capacity;\n        if (!Number.isInteger(defaultCapacity) || defaultCapacity < 0) {\n            return null;\n        }\n\n        const variantId = product.variant_id ?? item.variant_id;\n        if (variantId === undefined || variantId === null || !Number.isInteger(variantId) || variantId <= 0) {\n            return null;\n        }\n        if (product.variant_id && item.variant_id && product.variant_id !== item.variant_id) {\n            return null;\n        }\n\n        const existing = map.get(item.product_id);\n        if (existing) {\n            if (existing.variant_id !== variantId) {\n                return null;\n            }\n            existing.qty += item.qty;\n            map.set(item.product_id, existing);\n            continue;\n        }\n\n        map.set(item.product_id, {\n            product_id: item.product_id,\n            variant_id: variantId,\n            qty: item.qty,\n            default_capacity: defaultCapacity,\n        });\n    }\n\n    return Array.from(map.values());\n}\n\nfunction parseHoldBody(body: Record<string, unknown>): HoldRequestBody | null {\n    const startDate = getString(body, 'start_date');\n    const endDate = getString(body, 'end_date');\n    const location = getString(body, 'location');\n    const items = body.items;\n\n    if (!startDate || !endDate || !location || !Array.isArray(items) || items.length === 0) {\n        return null;\n    }\n\n    const parsedItems: HoldRequestItemInput[] = [];\n    for (const entry of items) {\n        if (!isRecord(entry)) {\n            return null;\n        }\n        const productId = getNumber(entry, 'product_id');\n        const qty = getNumber(entry, 'qty');\n        const variantId = getOptionalNumber(entry, 'variant_id');\n\n        if (productId === null || !Number.isInteger(productId) || productId <= 0) {\n            return null;\n        }\n        if (qty === null || !Number.isInteger(qty) || qty <= 0) {\n            return null;\n        }\n        if (variantId !== undefined && (!Number.isInteger(variantId) || variantId <= 0)) {\n            return null;\n        }\n        parsedItems.push({\n            product_id: productId,\n            variant_id: variantId,\n            qty,\n        });\n    }\n\n    return {\n        start_date: startDate,\n        end_date: endDate,\n        location,\n        items: parsedItems,\n    };\n}\n\nfunction rateLimitKey(request: Request, scope: string): string {\n    const ip =\n        request.headers.get('CF-Connecting-IP') ||\n        request.headers.get('X-Forwarded-For') ||\n        'unknown';\n    return `${scope}:${ip}`;\n}\n\nfunction rateLimitResponse(resetAt: number): Response {\n    const retryAfter = Math.max(1, Math.ceil((resetAt - Date.now()) / 1000));\n    return new Response('Rate limit exceeded', {\n        status: 429,\n        headers: {\n            'Retry-After': retryAfter.toString(),\n        },\n    });\n}\n\nasync function readJsonBody(request: Request): Promise<Record<string, unknown> | null> {\n    try {\n        const data = await request.json();\n        return isRecord(data) ? data : null;\n    } catch {\n        return null;\n    }\n}\n\nfunction isRecord(value: unknown): value is Record<string, unknown> {\n    return typeof value === 'object' && value !== null && !Array.isArray(value);\n}\n\nfunction getString(record: Record<string, unknown>, key: string): string | null {\n    const value = record[key];\n    if (typeof value !== 'string') {\n        return null;\n    }\n    const trimmed = value.trim();\n    return trimmed.length > 0 ? trimmed : null;\n}\n\nfunction getNumber(record: Record<string, unknown>, key: string): number | null {\n    const value = record[key];\n    if (typeof value !== 'number' || !Number.isFinite(value)) {\n        return null;\n    }\n    return value;\n}\n\nfunction getOptionalNumber(record: Record<string, unknown>, key: string): number | undefined {\n    if (!(key in record)) {\n        return undefined;\n    }\n    const value = record[key];\n    if (typeof value !== 'number' || !Number.isFinite(value)) {\n        return undefined;\n    }\n    return value;\n}\n\nfunction readStringField(row: Record<string, unknown>, key: string): string | null {\n    const value = row[key];\n    if (typeof value === 'string') {\n        return value;\n    }\n    if (typeof value === 'number') {\n        return value.toString();\n    }\n    return null;\n}\n\nfunction toNumber(value: unknown): number | null {\n    if (typeof value === 'number' && Number.isFinite(value)) {\n        return value;\n    }\n    if (typeof value === 'string' && value.trim() !== '') {\n        const parsed = Number(value);\n        if (Number.isFinite(parsed)) {\n            return parsed;\n        }\n    }\n    return null;\n}\n\nfunction isPngDataUrl(value: string): boolean {\n    return value.startsWith('data:image/png;base64,') && value.length > 'data:image/png;base64,'.length;\n}\n", "import { Env } from './types';\nimport { SessionTokenPayload, verifySessionToken } from './auth';\nimport { checkRateLimit } from './rateLimit';\nimport { listDateStrings, parseDateParts, getTodayInTimeZone } from './date';\nimport { STORE_TIMEZONE } from './config';\n\ninterface AdminAuthContext {\n    shopId: number;\n    shopDomain: string;\n    payload: SessionTokenPayload;\n}\n\ninterface InventoryOverrideInput {\n    date: string;\n    capacity: number;\n}\n\nexport async function handleAdminRequest(request: Request, env: Env): Promise<Response> {\n    const rate = checkRateLimit(rateLimitKey(request, 'admin'), 120, 60_000);\n    if (!rate.allowed) {\n        return rateLimitResponse(rate.resetAt);\n    }\n\n    const auth = await requireAdminAuth(request, env);\n    if (auth instanceof Response) {\n        return auth;\n    }\n\n    const url = new URL(request.url);\n    const path = url.pathname.replace(/^\\/admin/, '');\n    const segments = path.split('/').filter(Boolean);\n    const method = request.method.toUpperCase();\n\n    if (segments.length === 1 && segments[0] === 'locations') {\n        if (method === 'GET') {\n            return handleLocationsGet(env, auth.shopId);\n        }\n        if (method === 'POST') {\n            return handleLocationsPost(request, env, auth.shopId);\n        }\n    }\n\n    if (segments.length === 2 && segments[0] === 'locations') {\n        if (method === 'PATCH') {\n            const id = parsePositiveInt(segments[1]);\n            if (!id) {\n                return jsonError('Invalid location id', 400);\n            }\n            return handleLocationsPatch(request, env, auth.shopId, id);\n        }\n    }\n\n    if (segments.length === 1 && segments[0] === 'products') {\n        if (method === 'GET') {\n            return handleProductsGet(env, auth.shopId);\n        }\n    }\n\n    if (segments.length === 2 && segments[0] === 'products') {\n        if (method === 'PATCH') {\n            const productId = parsePositiveInt(segments[1]);\n            if (!productId) {\n                return jsonError('Invalid product id', 400);\n            }\n            return handleProductsPatch(request, env, auth.shopId, productId);\n        }\n        if (method === 'DELETE') {\n            const productId = parsePositiveInt(segments[1]);\n            if (!productId) {\n                return jsonError('Invalid product id', 400);\n            }\n            return handleProductsDelete(env, auth.shopId, productId);\n        }\n    }\n\n    if (segments.length === 1 && segments[0] === 'inventory') {\n        if (method === 'GET') {\n            return handleInventoryGet(request, env, auth.shopId);\n        }\n        if (method === 'PUT') {\n            return handleInventoryPut(request, env, auth.shopId);\n        }\n    }\n\n    if (segments.length === 1 && segments[0] === 'bookings') {\n        if (method === 'GET') {\n            return handleBookingsGet(request, env, auth.shopId);\n        }\n    }\n\n    if (segments.length === 1 && segments[0] === 'dashboard') {\n        if (method === 'GET') {\n            return handleDashboardGet(env, auth.shopId);\n        }\n    }\n\n    if (segments.length >= 2 && segments[0] === 'agreement') {\n        if (segments.length === 2 && segments[1] === 'current') {\n            if (method === 'GET') {\n                return handleAgreementCurrent(env, auth.shopDomain);\n            }\n        }\n        if (segments.length === 2 && segments[1] === 'upload') {\n            if (method === 'POST') {\n                return handleAgreementUpload(request, env, auth.shopDomain, auth.payload);\n            }\n        }\n        if (segments.length === 2 && segments[1] === 'placement') {\n            if (method === 'POST') {\n                return handleAgreementPlacement(request, env, auth.shopDomain);\n            }\n        }\n        if (segments.length === 2 && segments[1] === 'signed') {\n            if (method === 'GET') {\n                return handleAgreementSignedList(request, env, auth.shopDomain);\n            }\n        }\n        if (segments.length === 3 && segments[1] === 'signed') {\n            if (method === 'GET') {\n                return handleAgreementSignedDetail(env, auth.shopDomain, segments[2]);\n            }\n        }\n        if (segments.length === 3 && segments[1] === 'activate') {\n            if (method === 'POST') {\n                return handleAgreementActivate(env, auth.shopDomain, segments[2]);\n            }\n        }\n    }\n\n    if (segments.length === 2 && segments[0] === 'bookings') {\n        if (method === 'GET') {\n            return handleBookingGet(env, auth.shopId, segments[1]);\n        }\n    }\n\n    if (segments.length === 3 && segments[0] === 'bookings' && segments[2] === 'complete') {\n        if (method === 'POST') {\n            return handleBookingComplete(env, auth.shopId, segments[1]);\n        }\n    }\n\n    if (segments.length === 1 && segments[0] === 'shopify-products') {\n        if (method === 'GET') {\n            return handleShopifyProductsGet(env, auth.shopId);\n        }\n    }\n\n    return new Response('Not Found', { status: 404 });\n}\n\nasync function requireAdminAuth(request: Request, env: Env): Promise<Response | AdminAuthContext> {\n    const token = getBearerToken(request);\n    if (!token) {\n        return jsonError('Missing session token', 401);\n    }\n\n    const payload = await verifySessionToken(\n        token,\n        env.SHOPIFY_API_SECRET,\n        env.SHOPIFY_API_KEY,\n        env.SHOPIFY_JWKS_URL\n    );\n    if (!payload) {\n        return jsonError('Invalid session token', 401);\n    }\n\n    const shopDomain = safeUrlHost(payload.dest);\n    if (!shopDomain) {\n        return jsonError('Invalid token destination', 401);\n    }\n\n    const shopRow = await env.DB.prepare('SELECT id FROM shops WHERE shop_domain = ? AND uninstalled_at IS NULL')\n        .bind(shopDomain)\n        .first();\n    if (!shopRow) {\n        return jsonError('Shop not found', 401);\n    }\n\n    return {\n        shopId: shopRow.id as number,\n        shopDomain,\n        payload,\n    };\n}\n\nasync function handleLocationsGet(env: Env, shopId: number): Promise<Response> {\n    const rows = await env.DB.prepare(\n        'SELECT id, code, name, lead_time_days, min_duration_days, active FROM locations WHERE shop_id = ? ORDER BY name'\n    )\n        .bind(shopId)\n        .all();\n    return Response.json({ ok: true, locations: rows.results ?? [] });\n}\n\nasync function handleLocationsPost(request: Request, env: Env, shopId: number): Promise<Response> {\n    const body = await readJsonBody(request);\n    if (!body) {\n        return jsonError('Invalid JSON body', 400);\n    }\n    const code = getString(body, 'code');\n    const name = getString(body, 'name');\n    if (!code || !name) {\n        return jsonError('Missing required fields', 400);\n    }\n    const leadTimeDays = getOptionalNumber(body, 'lead_time_days');\n    const minDurationDays = getOptionalNumber(body, 'min_duration_days');\n    const active = getOptionalBoolean(body, 'active');\n\n    const leadValue = leadTimeDays ?? 1;\n    const minValue = minDurationDays ?? 1;\n    if (!Number.isInteger(leadValue) || leadValue < 0 || !Number.isInteger(minValue) || minValue < 1) {\n        return jsonError('Invalid lead time or minimum duration', 400);\n    }\n\n    try {\n        await env.DB.prepare(\n            `INSERT INTO locations (shop_id, code, name, lead_time_days, min_duration_days, active)\n             VALUES (?, ?, ?, ?, ?, ?)`\n        )\n            .bind(shopId, code, name, leadValue, minValue, active ?? true)\n            .run();\n        return Response.json({ ok: true });\n    } catch (e) {\n        console.error('Locations insert failed', e);\n        return jsonError('Failed to create location', 500);\n    }\n}\n\nasync function handleLocationsPatch(\n    request: Request,\n    env: Env,\n    shopId: number,\n    locationId: number\n): Promise<Response> {\n    const body = await readJsonBody(request);\n    if (!body) {\n        return jsonError('Invalid JSON body', 400);\n    }\n    const existing = await env.DB.prepare(\n        'SELECT code, name, lead_time_days, min_duration_days, active FROM locations WHERE shop_id = ? AND id = ?'\n    )\n        .bind(shopId, locationId)\n        .first();\n    if (!existing) {\n        return jsonError('Location not found', 404);\n    }\n\n    const code = getOptionalString(body, 'code') ?? (existing.code as string);\n    const name = getOptionalString(body, 'name') ?? (existing.name as string);\n    const leadTimeDays = getOptionalNumber(body, 'lead_time_days') ?? (existing.lead_time_days as number);\n    const minDurationDays = getOptionalNumber(body, 'min_duration_days') ?? (existing.min_duration_days as number);\n    const active = getOptionalBoolean(body, 'active') ?? Boolean(existing.active);\n\n    if (!code || !name) {\n        return jsonError('Invalid location fields', 400);\n    }\n    if (!Number.isInteger(leadTimeDays) || leadTimeDays < 0 || !Number.isInteger(minDurationDays) || minDurationDays < 1) {\n        return jsonError('Invalid lead time or minimum duration', 400);\n    }\n\n    await env.DB.prepare(\n        `UPDATE locations\n         SET code = ?, name = ?, lead_time_days = ?, min_duration_days = ?, active = ?\n         WHERE shop_id = ? AND id = ?`\n    )\n        .bind(code, name, leadTimeDays, minDurationDays, active, shopId, locationId)\n        .run();\n\n    return Response.json({ ok: true });\n}\n\nasync function handleProductsGet(env: Env, shopId: number): Promise<Response> {\n    const rows = await env.DB.prepare(\n        'SELECT product_id, variant_id, rentable, default_capacity, deposit_variant_id, deposit_multiplier, updated_at FROM products WHERE shop_id = ? ORDER BY product_id'\n    )\n        .bind(shopId)\n        .all();\n    return Response.json({ ok: true, products: rows.results ?? [] });\n}\n\nasync function handleProductsPatch(\n    request: Request,\n    env: Env,\n    shopId: number,\n    productId: number\n): Promise<Response> {\n    const body = await readJsonBody(request);\n    if (!body) {\n        return jsonError('Invalid JSON body', 400);\n    }\n    const rentable = getOptionalBoolean(body, 'rentable');\n    const defaultCapacity = getOptionalNumber(body, 'default_capacity');\n    const variantId = getOptionalNumber(body, 'variant_id');\n    const depositVariantId = getOptionalNumber(body, 'deposit_variant_id');\n    const depositMultiplier = getOptionalNumber(body, 'deposit_multiplier');\n\n    if (defaultCapacity !== undefined && (!Number.isInteger(defaultCapacity) || defaultCapacity < 0)) {\n        return jsonError('Invalid default capacity', 400);\n    }\n    if (depositMultiplier !== undefined && (!Number.isInteger(depositMultiplier) || depositMultiplier < 1)) {\n        return jsonError('Invalid deposit multiplier', 400);\n    }\n\n    await env.DB.prepare(\n        `INSERT INTO products (\n            shop_id, product_id, variant_id, rentable, default_capacity,\n            deposit_variant_id, deposit_multiplier, updated_at\n        )\n        VALUES (?, ?, ?, ?, ?, ?, ?, datetime('now'))\n        ON CONFLICT(shop_id, product_id) DO UPDATE SET\n            variant_id = COALESCE(excluded.variant_id, products.variant_id),\n            rentable = COALESCE(excluded.rentable, products.rentable),\n            default_capacity = COALESCE(excluded.default_capacity, products.default_capacity),\n            deposit_variant_id = COALESCE(excluded.deposit_variant_id, products.deposit_variant_id),\n            deposit_multiplier = COALESCE(excluded.deposit_multiplier, products.deposit_multiplier),\n            updated_at = datetime('now')`\n    )\n        .bind(\n            shopId,\n            productId,\n            variantId ?? null,\n            rentable ?? null,\n            defaultCapacity ?? null,\n            depositVariantId ?? null,\n            depositMultiplier ?? null\n        )\n        .run();\n\n    return Response.json({ ok: true });\n}\n\nasync function handleProductsDelete(env: Env, shopId: number, productId: number): Promise<Response> {\n    await env.DB.prepare('DELETE FROM products WHERE shop_id = ? AND product_id = ?')\n        .bind(shopId, productId)\n        .run();\n    return Response.json({ ok: true });\n}\n\nasync function handleInventoryGet(request: Request, env: Env, shopId: number): Promise<Response> {\n    const url = new URL(request.url);\n    const productId = parsePositiveInt(url.searchParams.get('product_id') || '');\n    const startDate = url.searchParams.get('start_date');\n    const endDate = url.searchParams.get('end_date');\n\n    if (!productId || !startDate || !endDate) {\n        return jsonError('Missing required parameters', 400);\n    }\n\n    const dateList = listDateStrings(startDate, endDate);\n    if (!dateList) {\n        return jsonError('Invalid date range', 400);\n    }\n\n    const product = await env.DB.prepare(\n        'SELECT default_capacity FROM products WHERE shop_id = ? AND product_id = ?'\n    )\n        .bind(shopId, productId)\n        .first();\n    if (!product) {\n        return jsonError('Product not found', 404);\n    }\n    const defaultCapacity = product.default_capacity as number;\n\n    const rows = await env.DB.prepare(\n        'SELECT date, capacity, reserved_qty FROM inventory_day WHERE shop_id = ? AND product_id = ? AND date >= ? AND date <= ?'\n    )\n        .bind(shopId, productId, startDate, endDate)\n        .all();\n    const map = new Map<string, { capacity: number; reserved_qty: number }>();\n    for (const row of rows.results ?? []) {\n        map.set(row.date as string, {\n            capacity: row.capacity as number,\n            reserved_qty: row.reserved_qty as number,\n        });\n    }\n\n    const inventory = dateList.map((date) => {\n        const found = map.get(date);\n        return {\n            date,\n            capacity: found ? found.capacity : defaultCapacity,\n            reserved_qty: found ? found.reserved_qty : 0,\n        };\n    });\n\n    return Response.json({ ok: true, inventory });\n}\n\nasync function handleInventoryPut(request: Request, env: Env, shopId: number): Promise<Response> {\n    const body = await readJsonBody(request);\n    if (!body) {\n        return jsonError('Invalid JSON body', 400);\n    }\n    const productId = getNumber(body, 'product_id');\n    if (!productId || !Number.isInteger(productId) || productId <= 0) {\n        return jsonError('Invalid product id', 400);\n    }\n\n    const overrides = body.overrides;\n    if (!Array.isArray(overrides) || overrides.length === 0) {\n        return jsonError('Missing overrides', 400);\n    }\n\n    const normalized: InventoryOverrideInput[] = [];\n    const seenDates = new Set<string>();\n    for (const entry of overrides) {\n        if (!isRecord(entry)) {\n            return jsonError('Invalid override entry', 400);\n        }\n        const date = getString(entry, 'date');\n        const capacity = getNumber(entry, 'capacity');\n        if (date === null || !parseDateParts(date)) {\n            return jsonError('Invalid override date', 400);\n        }\n        if (capacity === null || !Number.isInteger(capacity) || capacity < 0) {\n            return jsonError('Invalid override capacity', 400);\n        }\n        if (seenDates.has(date)) {\n            return jsonError('Duplicate override date', 400);\n        }\n        seenDates.add(date);\n        normalized.push({ date, capacity });\n    }\n\n    const statements: D1PreparedStatement[] = [];\n    for (const override of normalized) {\n        statements.push(\n            env.DB.prepare(\n                `INSERT OR IGNORE INTO inventory_day (shop_id, product_id, date, capacity, reserved_qty)\n                 VALUES (?, ?, ?, ?, 0)`\n            ).bind(shopId, productId, override.date, override.capacity)\n        );\n        statements.push(\n            env.DB.prepare(\n                `UPDATE inventory_day\n                 SET capacity = ?\n                 WHERE shop_id = ? AND product_id = ? AND date = ? AND reserved_qty <= ?`\n            ).bind(override.capacity, shopId, productId, override.date, override.capacity)\n        );\n        statements.push(\n            env.DB.prepare(\n                `SELECT CASE WHEN EXISTS (\n                    SELECT 1 FROM inventory_day\n                    WHERE shop_id = ? AND product_id = ? AND date = ? AND reserved_qty <= ?\n                ) THEN 1 ELSE 1/0 END;`\n            ).bind(shopId, productId, override.date, override.capacity)\n        );\n    }\n\n    try {\n        await env.DB.batch(statements);\n    } catch (e) {\n        console.error('Inventory override failed', e);\n        return jsonError('Inventory override failed', 409);\n    }\n\n    return Response.json({ ok: true });\n}\n\nasync function handleBookingsGet(request: Request, env: Env, shopId: number): Promise<Response> {\n    const url = new URL(request.url);\n    const status = url.searchParams.get('status');\n    const startDate = url.searchParams.get('start_date');\n    const endDate = url.searchParams.get('end_date');\n    const search = url.searchParams.get('search');\n\n    if ((startDate && !parseDateParts(startDate)) || (endDate && !parseDateParts(endDate))) {\n        return jsonError('Invalid date range', 400);\n    }\n\n    let sql =\n        'SELECT booking_token, status, location_code, start_date, end_date, order_id, invalid_reason, created_at, updated_at, customer_name, customer_email, revenue, fulfillment_type, delivery_address FROM bookings WHERE shop_id = ?';\n    const bindings: (string | number)[] = [shopId];\n    if (status) {\n        sql += ' AND status = ?';\n        bindings.push(status);\n    }\n    if (startDate) {\n        sql += ' AND start_date >= ?';\n        bindings.push(startDate);\n    }\n    if (endDate) {\n        sql += ' AND end_date <= ?';\n        bindings.push(endDate);\n    }\n    if (search) {\n        const term = `%${search}%`;\n        sql += ' AND (booking_token LIKE ? OR order_id LIKE ? OR customer_name LIKE ? OR customer_email LIKE ?)';\n        bindings.push(term, term, term, term);\n    }\n    sql += ' ORDER BY start_date DESC';\n\n    const rows = await env.DB.prepare(sql).bind(...bindings).all();\n    return Response.json({ ok: true, bookings: rows.results ?? [] });\n}\n\nasync function handleBookingGet(env: Env, shopId: number, bookingToken: string): Promise<Response> {\n    const booking = await env.DB.prepare(\n        `SELECT id, booking_token, status, location_code, start_date, end_date, expires_at, order_id, invalid_reason, created_at, updated_at, customer_name, customer_email, revenue, fulfillment_type, delivery_address\n         FROM bookings WHERE shop_id = ? AND booking_token = ?`\n    )\n        .bind(shopId, bookingToken)\n        .first();\n    if (!booking) {\n        return jsonError('Booking not found', 404);\n    }\n\n    const items = await env.DB.prepare(\n        'SELECT product_id, variant_id, qty FROM booking_items WHERE booking_id = ? ORDER BY product_id'\n    )\n        .bind(booking.id)\n        .all();\n    const days = await env.DB.prepare(\n        'SELECT product_id, date, qty FROM booking_days WHERE booking_id = ? ORDER BY date, product_id'\n    )\n        .bind(booking.id)\n        .all();\n\n    return Response.json({\n        ok: true,\n        booking,\n        items: items.results ?? [],\n        days: days.results ?? [],\n    });\n}\n\nasync function handleDashboardGet(env: Env, shopId: number): Promise<Response> {\n    const today = getTodayInTimeZone(STORE_TIMEZONE);\n\n    // activeBookings: CONFIRMED and overlapping today\n    const activeBookingsStmt = env.DB.prepare(\n        `SELECT COUNT(*) as count FROM bookings \n         WHERE shop_id = ? AND status = 'CONFIRMED' AND start_date <= ? AND end_date >= ?`\n    ).bind(shopId, today, today);\n\n    // pendingHolds: HOLD\n    const pendingHoldsStmt = env.DB.prepare(\n        `SELECT COUNT(*) as count FROM bookings \n         WHERE shop_id = ? AND status = 'HOLD'`\n    ).bind(shopId);\n\n    // pickups: start_date = today, CONFIRMED/HOLD\n    const pickupsStmt = env.DB.prepare(\n        `SELECT booking_token, location_code, order_id, status FROM bookings \n         WHERE shop_id = ? AND start_date = ? AND status IN ('CONFIRMED', 'HOLD')`\n    ).bind(shopId, today);\n\n    // dropoffs: end_date = today, CONFIRMED/HOLD\n    const dropoffsStmt = env.DB.prepare(\n        `SELECT booking_token, location_code, order_id, status FROM bookings \n         WHERE shop_id = ? AND end_date = ? AND status IN ('CONFIRMED', 'HOLD')`\n    ).bind(shopId, today);\n\n    // upcoming: start_date > today, CONFIRMED\n    const upcomingStmt = env.DB.prepare(\n        `SELECT booking_token, start_date, end_date, location_code, status, order_id, customer_name FROM bookings \n         WHERE shop_id = ? AND start_date > ? AND status = 'CONFIRMED' \n         ORDER BY start_date ASC LIMIT 5`\n    ).bind(shopId, today);\n\n    // history: recent\n    const historyStmt = env.DB.prepare(\n        `SELECT booking_token, start_date, end_date, status, created_at, invalid_reason FROM bookings \n         WHERE shop_id = ? \n         ORDER BY created_at DESC LIMIT 10`\n    ).bind(shopId);\n\n    const bookingsCountStmt = env.DB.prepare(\n        `SELECT COUNT(*) as count FROM bookings WHERE shop_id = ? AND status = 'CONFIRMED'`\n    ).bind(shopId);\n\n    const cancelledCountStmt = env.DB.prepare(\n        `SELECT COUNT(*) as count FROM bookings WHERE shop_id = ? AND status IN ('CANCELLED', 'EXPIRED', 'INVALID')`\n    ).bind(shopId);\n\n    const revenueStmt = env.DB.prepare(\n        `SELECT SUM(revenue) as total FROM bookings WHERE shop_id = ? AND status = 'CONFIRMED'`\n    ).bind(shopId);\n\n    const results = await env.DB.batch([\n        activeBookingsStmt,\n        pendingHoldsStmt,\n        pickupsStmt,\n        dropoffsStmt,\n        upcomingStmt,\n        historyStmt,\n        bookingsCountStmt,\n        cancelledCountStmt,\n        revenueStmt,\n        // Product breakdown (count only for now)\n        env.DB.prepare(\n            `SELECT product_id, COUNT(*) as count \n             FROM booking_items \n             JOIN bookings ON bookings.id = booking_items.booking_id \n             WHERE bookings.shop_id = ? AND bookings.status = 'CONFIRMED' \n             GROUP BY product_id`\n        ).bind(shopId)\n    ]);\n\n    // Check bounds since we added a query\n    const productStats = results.length > 9 ? results[9].results : [];\n\n    return Response.json({\n        ok: true,\n        todayDate: today,\n        stats: {\n            active_bookings: (results[0].results?.[0] as any)?.count ?? 0,\n            pending_holds: (results[1].results?.[0] as any)?.count ?? 0,\n            bookings_count: (results[6].results?.[0] as any)?.count ?? 0,\n            cancelled_count: (results[7].results?.[0] as any)?.count ?? 0,\n            revenue: (results[8].results?.[0] as any)?.total ?? 0\n        },\n        productStats: productStats ?? [],\n        todayActivity: {\n            pickups: results[2].results ?? [],\n            dropoffs: results[3].results ?? [],\n        },\n        upcomingBookings: results[4].results ?? [],\n        recentHistory: results[5].results ?? []\n    });\n}\n\nasync function handleBookingComplete(env: Env, shopId: number, bookingToken: string): Promise<Response> {\n    const booking = await env.DB.prepare(\n        `SELECT id, order_id, status FROM bookings WHERE shop_id = ? AND booking_token = ?`\n    ).bind(shopId, bookingToken).first();\n\n    if (!booking) {\n        return jsonError('Booking not found', 404);\n    }\n    const orderId = booking.order_id as number;\n\n    let fulfillmentResult = { success: false, message: 'No Order ID' };\n\n    if (orderId) {\n        fulfillmentResult = await fulfillShopifyOrder(env, shopId, orderId);\n    }\n\n    await env.DB.prepare(\n        `UPDATE bookings SET status = 'RELEASED', updated_at = datetime('now') WHERE id = ?`\n    ).bind(booking.id).run();\n\n    return Response.json({ ok: true, fulfillment: fulfillmentResult });\n}\n\nasync function fulfillShopifyOrder(env: Env, shopId: number, orderId: number): Promise<{ success: boolean; message: string }> {\n    const shopRow = await env.DB.prepare('SELECT shop_domain, access_token FROM shops WHERE id = ?')\n        .bind(shopId).first();\n    if (!shopRow) return { success: false, message: 'Shop not found' };\n\n    const { shop_domain, access_token } = shopRow as { shop_domain: string; access_token: string };\n\n    const foRes = await fetch(`https://${shop_domain}/admin/api/2025-10/orders/${orderId}/fulfillment_orders.json`, {\n        headers: { 'X-Shopify-Access-Token': access_token }\n    });\n\n    if (!foRes.ok) return { success: false, message: 'Failed to fetch fulfillment orders' };\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    const foData = await foRes.json() as any;\n    const fulfillmentOrders = foData.fulfillment_orders;\n\n    if (!fulfillmentOrders || fulfillmentOrders.length === 0) {\n        return { success: false, message: 'No fulfillment orders found' };\n    }\n\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    const openOrders = fulfillmentOrders.filter((fo: any) => fo.status === 'open');\n    if (openOrders.length === 0) return { success: true, message: 'Order already fulfilled' };\n\n    const targetFo = openOrders[0];\n    const payload = {\n        fulfillment: {\n            line_items_by_fulfillment_order: [{\n                fulfillment_order_id: targetFo.id\n            }]\n        }\n    };\n\n    const createRes = await fetch(`https://${shop_domain}/admin/api/2025-10/fulfillments.json`, {\n        method: 'POST',\n        headers: {\n            'X-Shopify-Access-Token': access_token,\n            'Content-Type': 'application/json'\n        },\n        body: JSON.stringify(payload)\n    });\n\n    if (!createRes.ok) {\n        const txt = await createRes.text();\n        console.error('Fulfillment failed', txt);\n        return { success: false, message: 'Fulfillment failed' };\n    }\n\n    return { success: true, message: 'Fulfilled' };\n}\n\nasync function handleShopifyProductsGet(env: Env, shopId: number): Promise<Response> {\n    const shopRow = await env.DB.prepare('SELECT shop_domain, access_token FROM shops WHERE id = ?')\n        .bind(shopId).first();\n    if (!shopRow) return jsonError('Shop not found', 404);\n\n    const { shop_domain, access_token } = shopRow as { shop_domain: string; access_token: string };\n\n    const query = `\n    {\n      products(first: 50, sortKey: TITLE) {\n        edges {\n          node {\n            id\n            title\n            status\n            images(first: 1) {\n              edges {\n                node {\n                  url\n                }\n              }\n            }\n            variants(first: 20) {\n              edges {\n                node {\n                  id\n                  title\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n    `;\n\n    try {\n        const response = await fetch(`https://${shop_domain}/admin/api/2025-10/graphql.json`, {\n            method: 'POST',\n            headers: {\n                'X-Shopify-Access-Token': access_token,\n                'Content-Type': 'application/json',\n            },\n            body: JSON.stringify({ query }),\n        });\n\n        if (!response.ok) {\n            const text = await response.text();\n            console.error('GraphQL HTTP Error', text);\n            return jsonError('Failed to fetch products from Shopify (HTTP)', 502);\n        }\n\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        const body = await response.json() as any;\n        if (body.errors) {\n            console.error('GraphQL Errors', JSON.stringify(body.errors));\n            return jsonError('Failed to fetch products from Shopify (GraphQL)', 502);\n        }\n\n        const rawProducts = body.data?.products?.edges || [];\n\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        const products = rawProducts.map((edge: any) => {\n            const node = edge.node;\n            const productId = parseInt(node.id.split('/').pop() || '0');\n\n            return {\n                id: productId,\n                title: node.title,\n                status: node.status,\n                // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                images: node.images.edges.map((imgEdge: any) => ({\n                    src: imgEdge.node.url\n                })),\n                // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                variants: node.variants.edges.map((varEdge: any) => ({\n                    id: parseInt(varEdge.node.id.split('/').pop() || '0'),\n                    title: varEdge.node.title\n                }))\n            };\n        });\n\n        return Response.json({ ok: true, products });\n    } catch (e) {\n        console.error('Shopify fetch exception', e);\n        return jsonError('Exception fetching products', 500);\n    }\n}\n\ninterface AgreementResponse {\n    id: string;\n    version: number;\n    active: boolean;\n    title: string | null;\n    pdf_url: string;\n    pdf_storage_type: string;\n    pdf_sha256: string | null;\n    page_number: number;\n    x: number;\n    y: number;\n    width: number;\n    height: number;\n    created_at: string;\n    created_by: string | null;\n}\n\ninterface SignedAgreementListItem {\n    id: string;\n    agreement_id: string;\n    agreement_version: number;\n    agreement_title: string | null;\n    cart_token: string;\n    order_id: string | null;\n    customer_email: string | null;\n    signed_at: string;\n    status: string;\n}\n\ninterface SignedAgreementDetail extends SignedAgreementListItem {\n    signature_png_base64: string;\n}\n\nasync function handleAgreementCurrent(env: Env, shopDomain: string): Promise<Response> {\n    const row = await env.DB.prepare(\n        `SELECT id, shop_domain, version, active, title, pdf_storage_type, pdf_storage_key, pdf_sha256,\n                page_number, x, y, width, height, created_at, created_by\n         FROM agreements\n         WHERE shop_domain = ? AND active = 1\n         ORDER BY version DESC\n         LIMIT 1`\n    )\n        .bind(shopDomain)\n        .first();\n\n    if (!row || !isRecord(row)) {\n        return Response.json({ ok: true, agreement: null });\n    }\n\n    const agreement = mapAgreementRow(row);\n    if (!agreement) {\n        return jsonError('Failed to read agreement', 500);\n    }\n\n    return Response.json({ ok: true, agreement });\n}\n\nasync function handleAgreementUpload(\n    request: Request,\n    env: Env,\n    shopDomain: string,\n    payload: SessionTokenPayload\n): Promise<Response> {\n    const body = await readJsonBody(request);\n    if (!body) {\n        return jsonError('Invalid JSON body', 400);\n    }\n\n    const title = getOptionalString(body, 'title') ?? null;\n    const pdfUrl = getString(body, 'pdf_url');\n    const pdfSha = getOptionalString(body, 'pdf_sha256') ?? null;\n    const pdfType = getOptionalString(body, 'pdf_storage_type') ?? 'EXTERNAL';\n    const pageNumberRaw = getOptionalPositiveInt(body, 'page_number');\n    const xRaw = getOptionalNumber(body, 'x');\n    const yRaw = getOptionalNumber(body, 'y');\n    const widthRaw = getOptionalNumber(body, 'width');\n    const heightRaw = getOptionalNumber(body, 'height');\n\n    const pageNumber = pageNumberRaw ?? 1;\n    const x = xRaw ?? 0.1;\n    const y = yRaw ?? 0.8;\n    const width = widthRaw ?? 0.3;\n    const height = heightRaw ?? 0.1;\n\n    if (!pdfUrl || !isValidPdfUrl(pdfUrl)) {\n        return jsonError('Invalid pdf_url', 400);\n    }\n\n    if (isInvalidOptionalNumber(body, 'page_number', pageNumberRaw)) {\n        return jsonError('Invalid page_number', 400);\n    }\n    if (isInvalidOptionalNumber(body, 'x', xRaw)) {\n        return jsonError('Invalid x', 400);\n    }\n    if (isInvalidOptionalNumber(body, 'y', yRaw)) {\n        return jsonError('Invalid y', 400);\n    }\n    if (isInvalidOptionalNumber(body, 'width', widthRaw)) {\n        return jsonError('Invalid width', 400);\n    }\n    if (isInvalidOptionalNumber(body, 'height', heightRaw)) {\n        return jsonError('Invalid height', 400);\n    }\n    if (!isAllowedPdfStorageType(pdfType)) {\n        return jsonError('Invalid pdf_storage_type', 400);\n    }\n\n    if (!isNormalizedRect(x, y, width, height) || !Number.isInteger(pageNumber) || pageNumber < 1) {\n        return jsonError('Invalid signature placement', 400);\n    }\n\n    const versionRow = await env.DB.prepare(\n        'SELECT COALESCE(MAX(version), 0) as max_version FROM agreements WHERE shop_domain = ?'\n    )\n        .bind(shopDomain)\n        .first();\n    const maxVersion = isRecord(versionRow) ? toNumber(versionRow.max_version) ?? 0 : 0;\n    const nextVersion = maxVersion + 1;\n\n    const agreementId = crypto.randomUUID();\n    const createdBy = payload.sub ?? payload.sid ?? null;\n    const createdAt = new Date().toISOString();\n\n    try {\n        await env.DB.batch([\n            env.DB.prepare('UPDATE agreements SET active = 0 WHERE shop_domain = ?').bind(shopDomain),\n            env.DB.prepare(\n                `INSERT INTO agreements (\n                    id, shop_domain, version, active, title, pdf_storage_type, pdf_storage_key, pdf_sha256,\n                    page_number, x, y, width, height, created_at, created_by\n                )\n                VALUES (?, ?, ?, 1, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`\n            ).bind(\n                agreementId,\n                shopDomain,\n                nextVersion,\n                title,\n                pdfType,\n                pdfUrl,\n                pdfSha,\n                pageNumber,\n                x,\n                y,\n                width,\n                height,\n                createdAt,\n                createdBy\n            )\n        ]);\n    } catch (e) {\n        console.error('Agreement upload failed', e);\n        return jsonError('Failed to save agreement', 500);\n    }\n\n    return Response.json({\n        ok: true,\n        agreement: {\n            id: agreementId,\n            version: nextVersion,\n            active: true,\n            title,\n            pdf_url: pdfUrl,\n            pdf_storage_type: pdfType,\n            pdf_sha256: pdfSha,\n            page_number: pageNumber,\n            x,\n            y,\n            width,\n            height,\n            created_at: createdAt,\n            created_by: createdBy\n        }\n    });\n}\n\nasync function handleAgreementPlacement(request: Request, env: Env, shopDomain: string): Promise<Response> {\n    const body = await readJsonBody(request);\n    if (!body) {\n        return jsonError('Invalid JSON body', 400);\n    }\n\n    const agreementId = getOptionalString(body, 'agreement_id');\n    const pageNumber = getOptionalPositiveInt(body, 'page_number');\n    const x = getOptionalNumber(body, 'x');\n    const y = getOptionalNumber(body, 'y');\n    const width = getOptionalNumber(body, 'width');\n    const height = getOptionalNumber(body, 'height');\n\n    if (\n        !pageNumber ||\n        x === undefined ||\n        y === undefined ||\n        width === undefined ||\n        height === undefined ||\n        !isNormalizedRect(x, y, width, height)\n    ) {\n        return jsonError('Invalid placement fields', 400);\n    }\n\n    const target = agreementId\n        ? await env.DB.prepare(\n            'SELECT id FROM agreements WHERE shop_domain = ? AND id = ?'\n        ).bind(shopDomain, agreementId).first()\n        : await env.DB.prepare(\n            'SELECT id FROM agreements WHERE shop_domain = ? AND active = 1 ORDER BY version DESC LIMIT 1'\n        ).bind(shopDomain).first();\n\n    if (!target || !isRecord(target)) {\n        return jsonError('Agreement not found', 404);\n    }\n\n    await env.DB.prepare(\n        `UPDATE agreements\n         SET page_number = ?, x = ?, y = ?, width = ?, height = ?\n         WHERE shop_domain = ? AND id = ?`\n    )\n        .bind(pageNumber, x, y, width, height, shopDomain, target.id)\n        .run();\n\n    return Response.json({ ok: true });\n}\n\nasync function handleAgreementSignedList(request: Request, env: Env, shopDomain: string): Promise<Response> {\n    const url = new URL(request.url);\n    const status = url.searchParams.get('status');\n    const orderId = url.searchParams.get('order_id');\n    const email = url.searchParams.get('email');\n    const startDate = url.searchParams.get('start_date');\n    const endDate = url.searchParams.get('end_date');\n    const limit = clampInt(url.searchParams.get('limit'), 25, 1, 100);\n    const offset = clampInt(url.searchParams.get('offset'), 0, 0, 10_000);\n\n    let sql =\n        `SELECT s.id, s.agreement_id, s.cart_token, s.order_id, s.customer_email, s.signed_at, s.status,\n                a.version as agreement_version, a.title as agreement_title\n         FROM signed_agreements s\n         JOIN agreements a ON s.agreement_id = a.id\n         WHERE s.shop_domain = ?`;\n    const bindings: (string | number)[] = [shopDomain];\n\n    if (status) {\n        sql += ' AND s.status = ?';\n        bindings.push(status);\n    }\n    if (orderId) {\n        sql += ' AND s.order_id = ?';\n        bindings.push(orderId);\n    }\n    if (email) {\n        sql += ' AND s.customer_email LIKE ?';\n        bindings.push(`%${email}%`);\n    }\n    if (startDate) {\n        sql += ' AND date(s.signed_at) >= date(?)';\n        bindings.push(startDate);\n    }\n    if (endDate) {\n        sql += ' AND date(s.signed_at) <= date(?)';\n        bindings.push(endDate);\n    }\n\n    sql += ' ORDER BY s.signed_at DESC LIMIT ? OFFSET ?';\n    bindings.push(limit, offset);\n\n    const rows = await env.DB.prepare(sql).bind(...bindings).all();\n    const items = (rows.results ?? [])\n        .filter(isRecord)\n        .map((row) => ({\n            id: readStringField(row, 'id') ?? '',\n            agreement_id: readStringField(row, 'agreement_id') ?? '',\n            agreement_version: toNumber(row.agreement_version) ?? 0,\n            agreement_title: readStringField(row, 'agreement_title'),\n            cart_token: readStringField(row, 'cart_token') ?? '',\n            order_id: readStringField(row, 'order_id'),\n            customer_email: readStringField(row, 'customer_email'),\n            signed_at: readStringField(row, 'signed_at') ?? '',\n            status: readStringField(row, 'status') ?? 'pending'\n        }))\n        .filter((item) => item.id && item.agreement_id);\n\n    return Response.json({ ok: true, signed_agreements: items });\n}\n\nasync function handleAgreementSignedDetail(env: Env, shopDomain: string, signedId: string): Promise<Response> {\n    const row = await env.DB.prepare(\n        `SELECT s.id, s.agreement_id, s.cart_token, s.order_id, s.customer_email, s.signed_at, s.status,\n                s.signature_png_base64,\n                a.version as agreement_version, a.title as agreement_title\n         FROM signed_agreements s\n         JOIN agreements a ON s.agreement_id = a.id\n         WHERE s.shop_domain = ? AND s.id = ?`\n    )\n        .bind(shopDomain, signedId)\n        .first();\n\n    if (!row || !isRecord(row)) {\n        return jsonError('Signed agreement not found', 404);\n    }\n\n    const detail: SignedAgreementDetail = {\n        id: readStringField(row, 'id') ?? '',\n        agreement_id: readStringField(row, 'agreement_id') ?? '',\n        agreement_version: toNumber(row.agreement_version) ?? 0,\n        agreement_title: readStringField(row, 'agreement_title'),\n        cart_token: readStringField(row, 'cart_token') ?? '',\n        order_id: readStringField(row, 'order_id'),\n        customer_email: readStringField(row, 'customer_email'),\n        signed_at: readStringField(row, 'signed_at') ?? '',\n        status: readStringField(row, 'status') ?? 'pending',\n        signature_png_base64: readStringField(row, 'signature_png_base64') ?? ''\n    };\n\n    if (!detail.id || !detail.signature_png_base64) {\n        return jsonError('Signed agreement data missing', 500);\n    }\n\n    return Response.json({ ok: true, signed_agreement: detail });\n}\n\nasync function handleAgreementActivate(env: Env, shopDomain: string, agreementId: string): Promise<Response> {\n    const exists = await env.DB.prepare(\n        'SELECT id FROM agreements WHERE shop_domain = ? AND id = ?'\n    ).bind(shopDomain, agreementId).first();\n\n    if (!exists) {\n        return jsonError('Agreement not found', 404);\n    }\n\n    await env.DB.batch([\n        env.DB.prepare('UPDATE agreements SET active = 0 WHERE shop_domain = ?').bind(shopDomain),\n        env.DB.prepare('UPDATE agreements SET active = 1 WHERE shop_domain = ? AND id = ?').bind(shopDomain, agreementId)\n    ]);\n\n    return Response.json({ ok: true });\n}\n\nfunction mapAgreementRow(row: Record<string, unknown>): AgreementResponse | null {\n    const id = readStringField(row, 'id');\n    const pdfStorageKey = readStringField(row, 'pdf_storage_key');\n    const pdfStorageType = readStringField(row, 'pdf_storage_type');\n    if (!id || !pdfStorageKey || !pdfStorageType) {\n        return null;\n    }\n\n    const version = toNumber(row.version);\n    const pageNumber = toNumber(row.page_number);\n    const x = toNumber(row.x);\n    const y = toNumber(row.y);\n    const width = toNumber(row.width);\n    const height = toNumber(row.height);\n\n    if (\n        version === null ||\n        pageNumber === null ||\n        x === null ||\n        y === null ||\n        width === null ||\n        height === null\n    ) {\n        return null;\n    }\n\n    return {\n        id,\n        version,\n        active: Boolean(toNumber(row.active)),\n        title: readStringField(row, 'title'),\n        pdf_url: pdfStorageKey,\n        pdf_storage_type: pdfStorageType,\n        pdf_sha256: readStringField(row, 'pdf_sha256'),\n        page_number: pageNumber,\n        x,\n        y,\n        width,\n        height,\n        created_at: readStringField(row, 'created_at') ?? '',\n        created_by: readStringField(row, 'created_by')\n    };\n}\n\nfunction isNormalizedRect(x: number, y: number, width: number, height: number): boolean {\n    if (!isFiniteNumber(x) || !isFiniteNumber(y) || !isFiniteNumber(width) || !isFiniteNumber(height)) {\n        return false;\n    }\n    if (width <= 0 || height <= 0) {\n        return false;\n    }\n    return x >= 0 && y >= 0 && width <= 1 && height <= 1 && x + width <= 1 && y + height <= 1;\n}\n\nfunction isFiniteNumber(value: number): boolean {\n    return typeof value === 'number' && Number.isFinite(value);\n}\n\nfunction isValidPdfUrl(value: string): boolean {\n    try {\n        const parsed = new URL(value);\n        return parsed.protocol === 'https:' || parsed.protocol === 'http:';\n    } catch {\n        return false;\n    }\n}\n\nfunction isAllowedPdfStorageType(value: string): boolean {\n    return value === 'EXTERNAL' || value === 'SHOPIFY_FILES';\n}\n\nfunction isInvalidOptionalNumber(\n    record: Record<string, unknown>,\n    key: string,\n    parsed: number | undefined\n): boolean {\n    return key in record && parsed === undefined;\n}\n\nfunction clampInt(value: string | null, fallback: number, min: number, max: number): number {\n    if (!value) {\n        return fallback;\n    }\n    const parsed = Number(value);\n    if (!Number.isInteger(parsed)) {\n        return fallback;\n    }\n    return Math.min(max, Math.max(min, parsed));\n}\n\nfunction readStringField(row: Record<string, unknown>, key: string): string | null {\n    const value = row[key];\n    if (typeof value === 'string') {\n        return value;\n    }\n    if (typeof value === 'number') {\n        return value.toString();\n    }\n    return null;\n}\n\nfunction toNumber(value: unknown): number | null {\n    if (typeof value === 'number' && Number.isFinite(value)) {\n        return value;\n    }\n    if (typeof value === 'string' && value.trim() !== '') {\n        const parsed = Number(value);\n        if (Number.isFinite(parsed)) {\n            return parsed;\n        }\n    }\n    return null;\n}\n\nfunction getOptionalPositiveInt(record: Record<string, unknown>, key: string): number | undefined {\n    if (!(key in record)) {\n        return undefined;\n    }\n    const value = record[key];\n    if (typeof value === 'number' && Number.isInteger(value) && value > 0) {\n        return value;\n    }\n    return undefined;\n}\n\nfunction rateLimitKey(request: Request, scope: string): string {\n    const ip =\n        request.headers.get('CF-Connecting-IP') ||\n        request.headers.get('X-Forwarded-For') ||\n        'unknown';\n    return `${scope}:${ip}`;\n}\n\nfunction rateLimitResponse(resetAt: number): Response {\n    const retryAfter = Math.max(1, Math.ceil((resetAt - Date.now()) / 1000));\n    return new Response('Rate limit exceeded', {\n        status: 429,\n        headers: {\n            'Retry-After': retryAfter.toString(),\n        },\n    });\n}\n\nfunction getBearerToken(request: Request): string | null {\n    const auth = request.headers.get('Authorization');\n    if (auth && auth.startsWith('Bearer ')) {\n        return auth.slice('Bearer '.length).trim();\n    }\n    const token =\n        request.headers.get('X-Shopify-Session-Token') ||\n        request.headers.get('X-Shopify-Access-Token');\n    return token ? token.trim() : null;\n}\n\nfunction safeUrlHost(value: string): string | null {\n    try {\n        return new URL(value).host;\n    } catch {\n        return null;\n    }\n}\n\nfunction parsePositiveInt(value: string): number | null {\n    const parsed = Number(value);\n    if (!Number.isInteger(parsed) || parsed <= 0) {\n        return null;\n    }\n    return parsed;\n}\n\nasync function readJsonBody(request: Request): Promise<Record<string, unknown> | null> {\n    try {\n        const data = await request.json();\n        return isRecord(data) ? data : null;\n    } catch {\n        return null;\n    }\n}\n\nfunction isRecord(value: unknown): value is Record<string, unknown> {\n    return typeof value === 'object' && value !== null && !Array.isArray(value);\n}\n\nfunction getString(record: Record<string, unknown>, key: string): string | null {\n    const value = record[key];\n    if (typeof value !== 'string') {\n        return null;\n    }\n    const trimmed = value.trim();\n    return trimmed.length > 0 ? trimmed : null;\n}\n\nfunction getOptionalString(record: Record<string, unknown>, key: string): string | undefined {\n    if (!(key in record)) {\n        return undefined;\n    }\n    const value = record[key];\n    if (typeof value !== 'string') {\n        return undefined;\n    }\n    const trimmed = value.trim();\n    return trimmed.length > 0 ? trimmed : undefined;\n}\n\nfunction getNumber(record: Record<string, unknown>, key: string): number | null {\n    const value = record[key];\n    if (typeof value !== 'number' || !Number.isFinite(value)) {\n        return null;\n    }\n    return value;\n}\n\nfunction getOptionalNumber(record: Record<string, unknown>, key: string): number | undefined {\n    if (!(key in record)) {\n        return undefined;\n    }\n    const value = record[key];\n    if (typeof value !== 'number' || !Number.isFinite(value)) {\n        return undefined;\n    }\n    return value;\n}\n\nfunction getOptionalBoolean(record: Record<string, unknown>, key: string): boolean | undefined {\n    if (!(key in record)) {\n        return undefined;\n    }\n    const value = record[key];\n    if (typeof value !== 'boolean') {\n        return undefined;\n    }\n    return value;\n}\n\nfunction jsonError(message: string, status: number): Response {\n    return Response.json({ ok: false, error: message }, { status });\n}\n", "import { Env } from './types';\nimport { releaseBooking } from './bookingService';\n\ninterface ExpiredBookingRow {\n    id: string;\n}\n\nexport async function handleScheduled(event: ScheduledEvent, env: Env): Promise<void> {\n    console.log('Running hold cleanup cron', event.cron);\n    const expired = await env.DB.prepare(\n        \"SELECT id FROM bookings WHERE status = 'HOLD' AND datetime(expires_at) <= datetime('now')\"\n    ).all();\n\n    for (const row of expired.results ?? []) {\n        const bookingId = (row as unknown as ExpiredBookingRow).id;\n        if (!bookingId) {\n            continue;\n        }\n        try {\n            await releaseBooking(env.DB, bookingId, 'EXPIRED');\n        } catch (e) {\n            console.error('Failed to expire booking', bookingId, e);\n        }\n    }\n}\n", "import { handleAuth, handleAuthCallback } from './auth';\nimport { handleWebhook } from './webhooks';\nimport { handleProxyRequest } from './proxy';\nimport { handleAdminRequest } from './admin';\nimport { handleScheduled } from './scheduled';\nimport { Env } from './types';\n\nexport default {\n    async fetch(request: Request, env: Env, ctx: ExecutionContext): Promise<Response> {\n        const url = new URL(request.url);\n\n        const corsHeaders = {\n            'Access-Control-Allow-Origin': '*',\n            'Access-Control-Allow-Methods': 'GET, POST, PUT, DELETE, PATCH, OPTIONS',\n            'Access-Control-Allow-Headers': 'Content-Type, Authorization',\n        };\n\n        // Global CORS for OPTIONS\n        if (request.method === 'OPTIONS') {\n            return new Response(null, {\n                headers: corsHeaders,\n            });\n        }\n\n        let response: Response;\n\n        try {\n            if (url.pathname === '/auth') {\n                response = await handleAuth(request, env);\n            } else if (url.pathname === '/auth/callback') {\n                response = await handleAuthCallback(request, env);\n            } else if (url.pathname.startsWith('/webhooks')) {\n                response = await handleWebhook(request, env);\n            } else if (url.pathname.startsWith('/proxy')) {\n                response = await handleProxyRequest(request, env);\n            } else if (url.pathname.startsWith('/admin')) {\n                response = await handleAdminRequest(request, env);\n            } else {\n                response = new Response('Mexican Golf Cart Worker is Running');\n            }\n        } catch (e) {\n            console.error('Worker Error:', e);\n            response = new Response('Internal Server Error', { status: 500 });\n        }\n\n        // Clone headers to avoid mutating a potentially immutable Headers object\n        const newHeaders = new Headers(response.headers);\n        Object.entries(corsHeaders).forEach(([key, value]) => {\n            newHeaders.set(key, value);\n        });\n\n        return new Response(response.body, {\n            status: response.status,\n            statusText: response.statusText,\n            headers: newHeaders,\n        });\n    },\n    async scheduled(event: ScheduledEvent, env: Env, ctx: ExecutionContext): Promise<void> {\n        ctx.waitUntil(handleScheduled(event, env));\n    },\n};\n", "import type { Middleware } from \"./common\";\n\nconst drainBody: Middleware = async (request, env, _ctx, middlewareCtx) => {\n\ttry {\n\t\treturn await middlewareCtx.next(request, env);\n\t} finally {\n\t\ttry {\n\t\t\tif (request.body !== null && !request.bodyUsed) {\n\t\t\t\tconst reader = request.body.getReader();\n\t\t\t\twhile (!(await reader.read()).done) {}\n\t\t\t}\n\t\t} catch (e) {\n\t\t\tconsole.error(\"Failed to drain the unused request body.\", e);\n\t\t}\n\t}\n};\n\nexport default drainBody;\n", "import type { Middleware } from \"./common\";\n\ninterface JsonError {\n\tmessage?: string;\n\tname?: string;\n\tstack?: string;\n\tcause?: JsonError;\n}\n\nfunction reduceError(e: any): JsonError {\n\treturn {\n\t\tname: e?.name,\n\t\tmessage: e?.message ?? String(e),\n\t\tstack: e?.stack,\n\t\tcause: e?.cause === undefined ? undefined : reduceError(e.cause),\n\t};\n}\n\n// See comment in `bundle.ts` for details on why this is needed\nconst jsonError: Middleware = async (request, env, _ctx, middlewareCtx) => {\n\ttry {\n\t\treturn await middlewareCtx.next(request, env);\n\t} catch (e: any) {\n\t\tconst error = reduceError(e);\n\t\treturn Response.json(error, {\n\t\t\tstatus: 500,\n\t\t\theaders: { \"MF-Experimental-Error-Stack\": \"true\" },\n\t\t});\n\t}\n};\n\nexport default jsonError;\n", "\t\t\t\timport worker, * as OTHER_EXPORTS from \"/Users/abhinav/Documents/MexicanGolfCartApp/worker/src/index.ts\";\n\t\t\t\timport * as __MIDDLEWARE_0__ from \"/Users/abhinav/.nvm/versions/node/v24.11.1/lib/node_modules/wrangler/templates/middleware/middleware-ensure-req-body-drained.ts\";\nimport * as __MIDDLEWARE_1__ from \"/Users/abhinav/.nvm/versions/node/v24.11.1/lib/node_modules/wrangler/templates/middleware/middleware-miniflare3-json-error.ts\";\n\n\t\t\t\texport * from \"/Users/abhinav/Documents/MexicanGolfCartApp/worker/src/index.ts\";\n\t\t\t\tconst MIDDLEWARE_TEST_INJECT = \"__INJECT_FOR_TESTING_WRANGLER_MIDDLEWARE__\";\n\t\t\t\texport const __INTERNAL_WRANGLER_MIDDLEWARE__ = [\n\t\t\t\t\t\n\t\t\t\t\t__MIDDLEWARE_0__.default,__MIDDLEWARE_1__.default\n\t\t\t\t]\n\t\t\t\texport default worker;", "export type Awaitable<T> = T | Promise<T>;\n// TODO: allow dispatching more events?\nexport type Dispatcher = (\n\ttype: \"scheduled\",\n\tinit: { cron?: string }\n) => Awaitable<void>;\n\nexport type IncomingRequest = Request<\n\tunknown,\n\tIncomingRequestCfProperties<unknown>\n>;\n\nexport interface MiddlewareContext {\n\tdispatch: Dispatcher;\n\tnext(request: IncomingRequest, env: any): Awaitable<Response>;\n}\n\nexport type Middleware = (\n\trequest: IncomingRequest,\n\tenv: any,\n\tctx: ExecutionContext,\n\tmiddlewareCtx: MiddlewareContext\n) => Awaitable<Response>;\n\nconst __facade_middleware__: Middleware[] = [];\n\n// The register functions allow for the insertion of one or many middleware,\n// We register internal middleware first in the stack, but have no way of controlling\n// the order that addMiddleware is run in service workers so need an internal function.\nexport function __facade_register__(...args: (Middleware | Middleware[])[]) {\n\t__facade_middleware__.push(...args.flat());\n}\nexport function __facade_registerInternal__(\n\t...args: (Middleware | Middleware[])[]\n) {\n\t__facade_middleware__.unshift(...args.flat());\n}\n\nfunction __facade_invokeChain__(\n\trequest: IncomingRequest,\n\tenv: any,\n\tctx: ExecutionContext,\n\tdispatch: Dispatcher,\n\tmiddlewareChain: Middleware[]\n): Awaitable<Response> {\n\tconst [head, ...tail] = middlewareChain;\n\tconst middlewareCtx: MiddlewareContext = {\n\t\tdispatch,\n\t\tnext(newRequest, newEnv) {\n\t\t\treturn __facade_invokeChain__(newRequest, newEnv, ctx, dispatch, tail);\n\t\t},\n\t};\n\treturn head(request, env, ctx, middlewareCtx);\n}\n\nexport function __facade_invoke__(\n\trequest: IncomingRequest,\n\tenv: any,\n\tctx: ExecutionContext,\n\tdispatch: Dispatcher,\n\tfinalMiddleware: Middleware\n): Awaitable<Response> {\n\treturn __facade_invokeChain__(request, env, ctx, dispatch, [\n\t\t...__facade_middleware__,\n\t\tfinalMiddleware,\n\t]);\n}\n", "// This loads all middlewares exposed on the middleware object and then starts\n// the invocation chain. The big idea is that we can add these to the middleware\n// export dynamically through wrangler, or we can potentially let users directly\n// add them as a sort of \"plugin\" system.\n\nimport ENTRY, { __INTERNAL_WRANGLER_MIDDLEWARE__ } from \"/Users/abhinav/Documents/MexicanGolfCartApp/worker/.wrangler/tmp/bundle-C8yPJI/middleware-insertion-facade.js\";\nimport { __facade_invoke__, __facade_register__, Dispatcher } from \"/Users/abhinav/.nvm/versions/node/v24.11.1/lib/node_modules/wrangler/templates/middleware/common.ts\";\nimport type { WorkerEntrypointConstructor } from \"/Users/abhinav/Documents/MexicanGolfCartApp/worker/.wrangler/tmp/bundle-C8yPJI/middleware-insertion-facade.js\";\n\n// Preserve all the exports from the worker\nexport * from \"/Users/abhinav/Documents/MexicanGolfCartApp/worker/.wrangler/tmp/bundle-C8yPJI/middleware-insertion-facade.js\";\n\nclass __Facade_ScheduledController__ implements ScheduledController {\n\treadonly #noRetry: ScheduledController[\"noRetry\"];\n\n\tconstructor(\n\t\treadonly scheduledTime: number,\n\t\treadonly cron: string,\n\t\tnoRetry: ScheduledController[\"noRetry\"]\n\t) {\n\t\tthis.#noRetry = noRetry;\n\t}\n\n\tnoRetry() {\n\t\tif (!(this instanceof __Facade_ScheduledController__)) {\n\t\t\tthrow new TypeError(\"Illegal invocation\");\n\t\t}\n\t\t// Need to call native method immediately in case uncaught error thrown\n\t\tthis.#noRetry();\n\t}\n}\n\nfunction wrapExportedHandler(worker: ExportedHandler): ExportedHandler {\n\t// If we don't have any middleware defined, just return the handler as is\n\tif (\n\t\t__INTERNAL_WRANGLER_MIDDLEWARE__ === undefined ||\n\t\t__INTERNAL_WRANGLER_MIDDLEWARE__.length === 0\n\t) {\n\t\treturn worker;\n\t}\n\t// Otherwise, register all middleware once\n\tfor (const middleware of __INTERNAL_WRANGLER_MIDDLEWARE__) {\n\t\t__facade_register__(middleware);\n\t}\n\n\tconst fetchDispatcher: ExportedHandlerFetchHandler = function (\n\t\trequest,\n\t\tenv,\n\t\tctx\n\t) {\n\t\tif (worker.fetch === undefined) {\n\t\t\tthrow new Error(\"Handler does not export a fetch() function.\");\n\t\t}\n\t\treturn worker.fetch(request, env, ctx);\n\t};\n\n\treturn {\n\t\t...worker,\n\t\tfetch(request, env, ctx) {\n\t\t\tconst dispatcher: Dispatcher = function (type, init) {\n\t\t\t\tif (type === \"scheduled\" && worker.scheduled !== undefined) {\n\t\t\t\t\tconst controller = new __Facade_ScheduledController__(\n\t\t\t\t\t\tDate.now(),\n\t\t\t\t\t\tinit.cron ?? \"\",\n\t\t\t\t\t\t() => {}\n\t\t\t\t\t);\n\t\t\t\t\treturn worker.scheduled(controller, env, ctx);\n\t\t\t\t}\n\t\t\t};\n\t\t\treturn __facade_invoke__(request, env, ctx, dispatcher, fetchDispatcher);\n\t\t},\n\t};\n}\n\nfunction wrapWorkerEntrypoint(\n\tklass: WorkerEntrypointConstructor\n): WorkerEntrypointConstructor {\n\t// If we don't have any middleware defined, just return the handler as is\n\tif (\n\t\t__INTERNAL_WRANGLER_MIDDLEWARE__ === undefined ||\n\t\t__INTERNAL_WRANGLER_MIDDLEWARE__.length === 0\n\t) {\n\t\treturn klass;\n\t}\n\t// Otherwise, register all middleware once\n\tfor (const middleware of __INTERNAL_WRANGLER_MIDDLEWARE__) {\n\t\t__facade_register__(middleware);\n\t}\n\n\t// `extend`ing `klass` here so other RPC methods remain callable\n\treturn class extends klass {\n\t\t#fetchDispatcher: ExportedHandlerFetchHandler<Record<string, unknown>> = (\n\t\t\trequest,\n\t\t\tenv,\n\t\t\tctx\n\t\t) => {\n\t\t\tthis.env = env;\n\t\t\tthis.ctx = ctx;\n\t\t\tif (super.fetch === undefined) {\n\t\t\t\tthrow new Error(\"Entrypoint class does not define a fetch() function.\");\n\t\t\t}\n\t\t\treturn super.fetch(request);\n\t\t};\n\n\t\t#dispatcher: Dispatcher = (type, init) => {\n\t\t\tif (type === \"scheduled\" && super.scheduled !== undefined) {\n\t\t\t\tconst controller = new __Facade_ScheduledController__(\n\t\t\t\t\tDate.now(),\n\t\t\t\t\tinit.cron ?? \"\",\n\t\t\t\t\t() => {}\n\t\t\t\t);\n\t\t\t\treturn super.scheduled(controller);\n\t\t\t}\n\t\t};\n\n\t\tfetch(request: Request<unknown, IncomingRequestCfProperties>) {\n\t\t\treturn __facade_invoke__(\n\t\t\t\trequest,\n\t\t\t\tthis.env,\n\t\t\t\tthis.ctx,\n\t\t\t\tthis.#dispatcher,\n\t\t\t\tthis.#fetchDispatcher\n\t\t\t);\n\t\t}\n\t};\n}\n\nlet WRAPPED_ENTRY: ExportedHandler | WorkerEntrypointConstructor | undefined;\nif (typeof ENTRY === \"object\") {\n\tWRAPPED_ENTRY = wrapExportedHandler(ENTRY);\n} else if (typeof ENTRY === \"function\") {\n\tWRAPPED_ENTRY = wrapWorkerEntrypoint(ENTRY);\n}\nexport default WRAPPED_ENTRY;\n"],
  "mappings": "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",
  "names": ["isRecord", "rateLimitKey", "rateLimitResponse", "handleAgreementCurrent", "safeUrlHost", "readJsonBody", "getString", "getOptionalNumber", "getNumber", "isRecord", "toNumber", "readStringField", "jsonError"]
}
